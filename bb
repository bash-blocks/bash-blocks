#!/usr/bin/env bash
bb_array_bbSettingsSet(){ index="${1}";value="${2}";bb_array_settings["${index}"]="${value}";printf -v "${index}" "${value}";};bb_array_bbSettingsGet(){ index="${1}";printf ${bb_array_settings["${index}"]};};bb_array_blockSettingsSet(){ index="${1}";value="${2}";block_array_settings["${index}"]="${value}";printf -v "${index}" "${value}";};bb_array_blockSettingsGet(){ index="${1}";printf ${block_array_settings["${index}"]};};bb_array_declareBbDefaults(){ for key in "${!bb_array_settings[@]}";do value=${bb_array_settings[${key}]};printf -v "${key}" "${value}";done;};bb_array_declareBlockDefaults(){ for key in "${!block_array_settings[@]}";do value=${block_array_settings[${key}]};printf -v "${key}" "${value}";done;};bb_array_declareJsonAllServers(){ for key in "${!arrayJsonAllServers[@]}";do value=${arrayJsonAllServers[${key}]};printf -v "${key}" "${value}";done;};bb_array_declareJsonCurrentLoopServer(){ for key in "${!arrayJsonCurrentLoopServer[@]}";do value=${arrayJsonCurrentLoopServer[${key}]};printf -v "${key}" "${value}";done;};bb_array_serialiseToFile(){ mkdir -p ${bbv_bbPath}tmp/payload;local -n array=$1;if [ ${#array[@]} -gt 0 ];then for i in ${!array[@]};do printf "%s\n" "${i}=${array[$i]}">>"${bbv_bbPath}tmp/payload/${1}";done;fi;};bb_array_stringDelimeter(){ delim=$1;string=$2;unset arrayTmp;IFS=${delim} read -r -a arrayTmp<<<"${string}";unset IFS;arraySize=${#array[@]};};bb_awk_opsFile(){ local awkFunction="${1}";local file="${2}";local v1="${3}";local v2="${4}";local result;if [[ "${awkFunction}" == "getString_lastNonEmptyLine" ]];then result=$(awk 'NF{s=$0}END{print s}' ${file});elif [[ "${awkFunction}" == "getLineNumber_last" ]];then result=$(awk 'END{print NR}' "${file}");fi;printf "${result}";};bb_bash_parameterExpansion(){ expansionFunc="${1}";string="${2}";if [[ "${expansionFunc}" == "getSubstring_uptoLastOccurenceOfUnderscore" ]];then result=$(echo ${string%\_*});elif [[ "${expansionFunc}" == "getSubstring_uptoFirstOccurenceOfUnderscore" ]];then result=$(echo ${string%%\_*});elif [[ "${expansionFunc}" == "getSubstring_afterFirstOccurenceOfUnderscore" ]];then result=$(echo ${string#*_});elif [[ "${expansionFunc}" == "getSubstring_afterLastOccurenceOfUnderscore" ]];then result=$(echo ${string##*_});elif [[ "${expansionFunc}" == "getSubstring_uptoLastOccurenceOfColon" ]];then result=$(echo ${string%\:*});elif [[ "${expansionFunc}" == "getSubstring_uptoFirstOccurenceOfColon" ]];then result=$(echo ${string%%\:*});elif [[ "${expansionFunc}" == "getSubstring_afterFirstOccurenceOfColon" ]];then result=$(echo ${string#*:});elif [[ "${expansionFunc}" == "getSubstring_afterLastOccurenceOfColon" ]];then result=$(echo ${string##*:});fi;printf "${result}";};bb_check_doIf(){ local leftSide=${1};local test=${2};local rightSide=${3};local cmd=${4};if [ $leftSide $test $rightSide ];then ${cmd};fi;};bb_defaults_set(){ bb_array_settings["bbv_default_abortOnFail"]="true";bb_array_settings["bbv_default_debug"]="false";bb_array_settings["bbv_default_stagePause"]="5";};bb_display_bbBanner(){ stageTitle=${1};stageType=${2};STAGECOUNT=${3};stageTotal=${4};clear;echo "${b}${cyan}██████╗  █████╗ ███████╗██╗  ██╗      ██████╗ ██╗      ██████╗  ██████╗██╗  ██╗███████╗    ██╗${reset}";echo "${cyan}██╔══██╗██╔══██╗██╔════╝██║  ██║      ██╔══██╗██║     ██╔═══██╗██╔════╝██║ ██╔╝██╔════╝    ██║${reset}";echo "${b}${cyan}██████╔╝███████║███████╗███████║      ██████╔╝██║     ██║   ██║██║     █████╔╝ ███████╗    ██║${reset}";echo "${cyan}██╔══██╗██╔══██║╚════██║██╔══██║      ██╔══██╗██║     ██║   ██║██║     ██╔═██╗ ╚════██║    ╚═╝${reset}";echo "${b}${cyan}██████╔╝██║  ██║███████║██║  ██║      ██████╔╝███████╗╚██████╔╝╚██████╗██║  ██╗███████║    ██╗${reset}";echo "${cyan}╚═════╝ ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝      ╚═════╝ ╚══════╝ ╚═════╝  ╚═════╝╚═╝  ╚═╝╚══════╝    ╚═╝${reset}";if [[ "${bbv_switch_json}" == "true" ]]&&[[ ${bb_switch_help} != "true" ]];then printf "%s\n" "${b}${yellow}---------------------------------------------------------------------------------------${reset}";printf "%s\t\t\t%s\n" "${b}${yellow}block:" "${cyan}${build_block}${reset}";printf "%s\t%s\n" "${b}${yellow}block_start_time:" "${cyan}${script_start_display}${reset}";printf "%s\t%s\n" "${b}${yellow}block_requires_sudo:" "${cyan}${blockRequiresSudo}${reset}";printf "%s\n" "${b}${yellow}---------------------------------------------------------------------------------------${reset}";printf "%s\t\t%s\n" "${b}${yellow}version_bb:" "${cyan}${bb_VERSION}${reset}";printf "%s\t\t%s\n" "${b}${yellow}version_block:" "${cyan}${blockVersion}${reset}";printf "%s\n" "${b}${yellow}---------------------------------------------------------------------------------------${reset}";printf "%s\t\t%s\n" "${b}${yellow}server_json:" "${cyan}${bbv_jsonServers}${reset}";printf "%s\t\t%s\n" "${b}${yellow}build_folder:" "${cyan}${build_buildFolder}${reset}";printf "%s\n" "${b}${white}---------------------------------------------------------------------------------------${reset}";printf "%s\t\t%s\n" "${b}${cyan}STAGE_TITLE:" "${white}${stageTitle}${reset}";printf "%s\t\t%s\n" "${b}${cyan}STAGE_TYPE:" "${white}${stageType}${reset}";printf "%s\t\t%s\n" "${b}${cyan}STAGE_ORDER:" "${white}${STAGECOUNT_mc}${reset} of ${b}${white}${stageTotal}${reset}";printf "%s\n" "${b}${white}---------------------------------------------------------------------------------------${reset}";else printf "%s\n" "${b}${white}----------------------------------------------------------------------------------------------${reset}";fi;};bb_display_equalSpacing(){ local string1="${1}";local string2="${2}";local string1Colour="${3}";local string2Colour="${4}";local additionalTabs="${5}";local newline="${6}";local string1Length="${#string1}";local addTabs="";if [[ ${additionalTabs} -gt "0" ]];then for t in $(seq 1 ${additionalTabs});do addTabs="${addTabs}\t";done;fi;if [[ ${string1Length} -ge "1" ]]&&[[ ${string1Length} -le "7" ]];then tabString="\t\t\t\t\t";elif [[ ${string1Length} -ge "8" ]]&&[[ ${string1Length} -le "15" ]];then tabString="\t\t\t\t";elif [[ ${string1Length} -ge "16" ]]&&[[ ${string1Length} -le "23" ]];then tabString="\t\t\t";elif [[ ${string1Length} -ge "24" ]]&&[[ ${string1Length} -le "31" ]];then tabString="\t\t";else tabString="\t";fi;if [[ ${newline} == "true" ]];then printf "%s${addTabs}${tabString}%s\n" "${string1Colour}${string1}${reset}" "${string2Colour}${string2}${reset}";else printf "%s${addTabs}${tabString}%s" "${string1Colour}${string1}${reset}" "${string2Colour}${string2}${reset}";fi;};bb_display_msgColor(){ messageType="${1}";message1="${2}";message2="${3}";tab="${4}";newlinesBefore="${5}";newlinesAfter="${6}";tabString="";newlinesBeforeString="";newlinesAfterString="";if [[ "${tab}" != "0" ]];then for i in $(seq 1 ${tab});do tabString="${tabString}\t";done;fi;if [[ "${newlinesBefore}" != "0" ]];then for i in $(seq 1 ${newlinesBefore});do newlinesBeforeString="${newlinesBeforeString}\n";done;fi;if [[ "${newlinesAfter}" != "0" ]];then for i in $(seq 1 ${newlinesAfter});do newlinesAfterString="${newlinesAfterString}\n";done;fi;case ${messageType} in "STAGECOUNT_mc") printf "${newlinesBeforeString}%s${tabString}%s${newlinesAfterString}" "${b}${message1}${reset}" "${b}${message2}${reset}" ;; "TASK==>_mc") printf "${newlinesBeforeString}%s${tabString}%s${newlinesAfterString}" "${b}${cyan}==> ${message1}${reset}" "${b}${message2}${reset}" ;; "ERROR-->_mc") printf "${newlinesBeforeString}%s${tabString}%s${newlinesAfterString}" "${b}${red}==> ${message1}" "${yellow}${message2}${reset}" ;; "ALERT-->_mc") printf "${newlinesBeforeString}%s${tabString}%s${newlinesAfterString}" "${b}${yellow}--> ${message1}${reset}" "${b}${message2}${reset}" ;; "INFO-->_mc") printf "${newlinesBeforeString}%s${tabString}%s${newlinesAfterString}" "${reset}--> ${message1}" "${message2}${reset}" ;; "INFO-B-->_mc") printf "${newlinesBeforeString}%s${tabString}%s${newlinesAfterString}" "${b}--> ${message1}${reset}" "${message2}${reset}" ;; "INFO-BY-->_mc") printf "${newlinesBeforeString}%s${tabString}%s${newlinesAfterString}" "${b}--> ${yellow}${message1}${reset}" "${message2}${reset}" ;; "TICK-->_mc") printf "${newlinesBeforeString}%s%s${tabString}%s${newlinesAfterString}" "${b}--> ${tick} " "${yellow}${message1}${reset}" "${message2}${reset}" ;; "CROSS-->_mc") printf "${newlinesBeforeString}%s%s${tabString}%s${newlinesAfterString}" "${b}--> ${cross} " "${yellow}${message1}${reset}" "${message2}${reset}" ;; esac;};bb_display_textFormatting(){ black=`tput setaf 0`;red=`tput setaf 1`;green=`tput setaf 2`;yellow=`tput setaf 3`;blue=`tput setaf 4`;magenta=`tput setaf 5`;cyan=`tput setaf 6`;white=`tput setaf 7`;b=`tput bold`;u=`tput sgr 0 1`;ul=`tput smul`;xl=`tput rmul`;stou=`tput smso`;xtou=`tput rmso`;reverse=`tput rev`;reset=`tput sgr0`;pipe=${b}${green}\|\|${reset};tick="$(printf '\u2705')";cross="$(printf '\u274c')";task="$(printf '\u2692\n')";u="_";};bb_file_deserialiseToArray(){ local filePath="${1}";local clearArray="${2}";arrayName=${filePath##*/};if [[ "${clearArray}" == "true" ]];then unset ${arrayName}&&declare -gA ${arrayName};fi;readarray -t lines<"${filePath}";for line in "${lines[@]}";do key=${line%%=*};value=${line#*=};tmp="${arrayName}[$key]";printf -v "${tmp}" "${value}";done;};bb_file_getLastLineNoToMatchString(){ local file="${1}";local lastLineNumber="${2}";local matchString="${3}";local flag="false";for((i=${lastLineNumber};i>0;i--));do value=$(sed "${i}q;d" ${file});if [[ "${value}" == "${matchString}" ]];then flag="${i}";break;fi;done;printf "%s" "${flag}";};bb_file_unpackTar(){ file=${1};folder=${2};tar -xvf "${file}" -C "${folder}";};bb_folder_checkNotEmpty(){ local folderPath="${1}";if find "${folderPath}" -mindepth 1 -print -quit 2>/dev/null|grep -q .;then printf "%s" "true";else printf "%s" "false";fi;};bb_grep_ops(){ local grepFunction="${1}";local file="${2}";local searchString="${3}";local result;if [[ "${grepFunction}" == "getLineNumber_matchString" ]];then result=$(grep -Fn "${searchString}" "${file}");result=$(echo ${result%%\:*});fi;printf "${result}";};bb_install_bb(){ mkdir -p "${bbv_bbPath}servers_json_connect";mkdir -p "${bbv_bbPath}blocks";mkdir -p "${bbv_bbPath}installed-blocks";if [[ "${bbv_os}" == "Mac" ]];then bb_display_bbBanner "prepare brew for mac" "run locally" "1" "4";bb_display_msgColor "TASK==>_mc" "TASK: update or install brew manager" "" "1" "1" "1";brewList=$(brew list);if [[ $brewList == *"command not found"* ]];then bb_display_msgColor "ALERT-->_mc" "installing homebrew:" "" "1" "1" "0";else bb_display_msgColor "ALERT-->_mc" "updating homebrew:" "" "1" "1" "0";fi;/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)";bb_time_stageTimer;bb_display_bbBanner "install brew packages" "run locally" "2" "4";bb_display_msgColor "TASK==>_mc" "TASK: update or install brew packages" "" "1" "1" "1";if [[ $brewList == *"coreutils"* ]];then bb_display_msgColor "ALERT-->_mc" "updating core-utils:" "" "1" "1" "0";printf "%s\t" "$ brew upgrade coreutils";brew upgrade coreutils>/dev/null 2>&1;printf "%s\n" "${tick}";else bb_display_msgColor "ALERT-->_mc" "installing core-utils:" "" "1" "1" "0";printf "%s\t" "$ brew install coreutils";brew install coreutils>/dev/null 2>&1;printf "%s\n" "${tick}";fi;if [[ $brewList == *"bash"* ]];then bb_display_msgColor "ALERT-->_mc" "updating bash:" "" "1" "1" "0";printf "%s\t" "$ brew upgrade bash";brew upgrade bash>/dev/null 2>&1;printf "%s\n" "${tick}";else bb_display_msgColor "ALERT-->_mc" "installing bash:" "" "1" "1" "0";printf "%s\t" "$ brew install bash";brew install bash>/dev/null 2>&1;printf "%s\n" "${tick}";fi;if [[ $brewList == *"gnu-sed"* ]];then bb_display_msgColor "ALERT-->_mc" "updating gnu-sed:" "" "1" "1" "0";printf "%s\t" "$ brew upgrade gnu-sed";brew upgrade gnu-sed>/dev/null 2>&1;printf "%s\n" "${tick}";else bb_display_msgColor "ALERT-->_mc" "installing gnu-sed:" "" "1" "1" "0";printf "%s\t" "$ brew install gnu-sed";brew install gnu-sed>/dev/null 2>&1;printf "%s\n" "${tick}";fi;if [[ $brewList == *"iproute2mac"* ]];then bb_display_msgColor "ALERT-->_mc" "updating iproute2mac:" "" "1" "1" "0";printf "%s\t" "$ brew upgrade iproute2mac";brew upgrade iproute2mac>/dev/null 2>&1;printf "%s\n" "${tick}";else bb_display_msgColor "ALERT-->_mc" "installing iproute2mac:" "" "1" "1" "0";printf "%s\t" "$ brew install iproute2mac";brew install iproute2mac>/dev/null 2>&1;printf "%s\n" "${tick}";fi;if [[ $brewList == *"awk"* ]];then bb_display_msgColor "ALERT-->_mc" "updating awk:" "" "1" "1" "0";printf "%s\t" "$ brew upgrade awk";brew upgrade awk>/dev/null 2>&1;printf "%s\n" "${tick}";else bb_display_msgColor "ALERT-->_mc" "installing awk:" "" "1" "1" "0";printf "%s\t" "$ brew install awk";brew install awk>/dev/null 2>&1;printf "%s\n" "${tick}";fi;if [[ $brewList == *"jq"* ]];then bb_display_msgColor "ALERT-->_mc" "updating jq:" "" "1" "1" "0";printf "%s\t" "$ brew upgrade jq";brew upgrade jq>/dev/null 2>&1;printf "%s\n" "${tick}";else bb_display_msgColor "ALERT-->_mc" "installing jq:" "" "1" "1" "0";printf "%s\t" "$ brew install jjq";brew install jq>/dev/null 2>&1;printf "%s\n" "${tick}";fi;if [[ $brewList == *"ssh-copy-id"* ]];then bb_display_msgColor "ALERT-->_mc" "updating ssh-copy-id:" "" "1" "1" "0";printf "%s\t" "$ brew upgrade ssh-copy-id";brew upgrade ssh-copy-id>/dev/null 2>&1;printf "%s\n" "${tick}";else bb_display_msgColor "ALERT-->_mc" "installing ssh-copy-id:" "" "1" "1" "0";printf "%s\t" "$ brew install ssh-copy-id";brew install ssh-copy-id>/dev/null 2>&1;printf "%s\n" "${tick}";fi;if [[ $brewList == *"grep"* ]];then bb_display_msgColor "ALERT-->_mc" "updating grep" "" "1" "1" "0";printf "%s\t" "$ brew uninstall grep && brew install grep --with-default-names (takes ~ 2m)";brew uninstall grep>/dev/null 2>&1;brew install grep --with-default-names>/dev/null 2>&1;printf "%s\n" "${tick}";else bb_display_msgColor "ALERT-->_mc" "installing ssh-copy-id:" "" "1" "1" "0";printf "%s\t" "$ brew install grep --with-default-names     (takes ~ 2m)";brew install grep --with-default-names>/dev/null 2>&1;printf "%s\n" "${tick}";fi;if [[ $brewList == *"curl"* ]];then bb_display_msgColor "ALERT-->_mc" "updating curl:" "" "1" "1" "0";printf "%s\t" "$ brew upgrade curl";brew upgrade curl>/dev/null 2>&1;printf "%s\n" "${tick}";else bb_display_msgColor "ALERT-->_mc" "installing curl:" "" "1" "1" "0";printf "%s\t" "$ brew install curl";brew install curl>/dev/null 2>&1;printf "%s\n" "${tick}";fi;bb_time_stageTimer;bb_display_bbBanner "add bash-blocks to path" "run locally" "3" "4";bb_display_msgColor "TASK==>_mc" "TASK: add bash-blocks to path so it can be run from anywhere" "" "1" "1" "1";echo "${b}---> delete any existing labelled block from:  ${yellow}~/.bash_profile${reset}";echo "${b}---> add new labelled block to:                ${yellow}~/.bash_profile${reset}";bb_bash_configProfile "BB_HOME" "${bbv_bbPath}" "bb";bb_time_stageTimer;bb_display_bbBanner "finish" "run locally" "4" "4";bb_display_msgColor "TASK==>_mc" "TASK: confirm bash version > 4.0" "" "1" "1" "1";bash --version;bb_display_msgColor "TASK==>_mc" "TASK: confirm installed homebrew packages" "" "1" "1" "1";brew list;bb_display_msgColor "TASK==>_mc" "TASK: final tasks to complete Mac setup:";bb_display_msgColor "INFO-B-->_mc" "[1] source bash_profile" "" "1" "1" "1";bb_display_msgColor "INFO-B-->_mc" "$ source ~/.bash_profile" "" "1" "1" "1";bb_display_msgColor "INFO-B-->_mc" "[2] Confirm above bash version is 4 or greater:" "" "1" "1" "1";bb_display_msgColor "INFO-B-->_mc" "$ bash --version" "" "1" "1" "1";bb_display_msgColor "INFO-B-->_mc" "[3] If not, then point to homebrew version of bash:" "" "1" "1" "1";bb_display_msgColor "INFO-B-->_mc" "Open Mac settings --> Users&Groups --> right-click --> advanced options" "" "1" "1" "1";bb_display_msgColor "INFO-B-->_mc" "Change 'login shell' to use /usr/local/bin/bash" "" "1" "1" "1";bb_display_msgColor "INFO-B-->_mc" "Check version once more: $ bash --version" "" "1" "1" "1";bb_display_msgColor "INFO-B-->_mc" "[4] Enable ssh connections:" "" "1" "1" "1";bb_display_msgColor "INFO-B-->_mc" "Open Mac settings ---> Sharing" "" "1" "1" "1";bb_display_msgColor "INFO-B-->_mc" "Tick-box remote-login" "" "1" "1" "2";else bb_display_bbBanner "add bash-blocks to path" "run locally" "1" "2";bb_display_msgColor "TASK==>_mc" "TASK: add bash-blocks to path so it can be run from anywhere" "" "1" "1" "1";echo "${b}---> delete any existing labelled block from:  ${yellow}~/.bash_profile${reset}";echo "${b}---> add new labelled block to:                ${yellow}~/.bash_profile${reset}";bb_bash_configProfile "BB_HOME" "${bbv_bbPath}" "bb";if [[ "${bbv_os}" == "Ubuntu" ]];then bb_bash_configDebian;fi;bb_time_stageTimer;bb_display_bbBanner "finish" "run locally" "2" "2";bb_display_msgColor "TASK==>_mc" "TASK: confirm bash version > 4.0" "" "1" "1" "1";bash --version;bb_display_msgColor "TASK==>_mc" "TASK: final tasks to complete linux setup:";bb_display_msgColor "INFO-B-->_mc" "[1] source bash_profile" "" "1" "1" "1";bb_display_msgColor "INFO-B-->_mc" "$ source ~/.bash_profile" "" "1" "1" "1";bb_display_msgColor "INFO-B-->_mc" "[2] Confirm above bash version is 4 or greater:" "" "1" "1" "1";bb_display_msgColor "INFO-B-->_mc" "$ bash --version" "" "1" "1" "1";fi;};bb_install_block(){ res=$(git ls-remote https://github.com/bash-blocks/${bbv_blockToInstall});if [[ $? == "0" ]]&&[[ "${res}" != "" ]];then bb_display_bbBanner "install block" "run locally" "1" "2";bb_display_msgColor "TASK==>_mc" "TASK: install ${bbv_blockToInstall}" "" "1" "1" "1";bb_display_msgColor "INFO-B-->_mc" "[1] creating/updating folders:" "" "1" "1" "1";printf "%s\n" "--> ${bbv_bbPath}blocks/${bbv_blockToInstall}";sleep 1;printf "%s\n" "--> ${bbv_bbPath}blocks/${bbv_blockToInstall}/builds";sleep 1;printf "%s\n" "--> ${bbv_bbPath}blocks/${bbv_blockToInstall}/servers_json";sleep 1;printf "%s\n" "--> ${bbv_bbPath}blocks/${bbv_blockToInstall}/software";sleep 1;mkdir -p "${bbv_bbPath}blocks/${bbv_blockToInstall}";mkdir -p "${bbv_bbPath}blocks/${bbv_blockToInstall}/builds";mkdir -p "${bbv_bbPath}blocks/${bbv_blockToInstall}/servers_json";mkdir -p "${bbv_bbPath}blocks/${bbv_blockToInstall}/software";mkdir -p "${bbv_bbPath}tmp/";bb_display_msgColor "INFO-B-->_mc" "[2] cloning block:" "" "1" "1" "1";printf "%s" ${magenta};git clone "https://github.com/bash-blocks/${bbv_blockToInstall}.git" "${bbv_bbPath}tmp/";printf "%s" ${reset};bb_display_msgColor "INFO-B-->_mc" "[3] adding/replacing:" "" "1" "1" "1";printf "%s\n" "--> the minimised block file";sleep 1;printf "%s\n" "--> the json template file";sleep 1;printf "%s\n" "--> any software or build files";sleep 1;rm -rf "${bbv_bbPath}blocks/${bbv_blockToInstall}/${bbv_blockToInstall}";mv ${bbv_bbPath}tmp/${bbv_blockToInstall} ${bbv_bbPath}blocks/${bbv_blockToInstall}/;mv ${bbv_bbPath}tmp/servers_json/* ${bbv_bbPath}blocks/${bbv_blockToInstall}/servers_json/;if [ "$(ls -A ${bbv_bbPath}tmp/builds 2>/dev/null)" ];then mv ${bbv_bbPath}tmp/builds/* ${bbv_bbPath}blocks/${bbv_blockToInstall}/builds/;fi;if [ "$(ls -A ${bbv_bbPath}tmp/software 2>/dev/null)" ];then mv ${bbv_bbPath}tmp/software/* ${bbv_bbPath}blocks/${bbv_blockToInstall}/software/;fi;rm -rf "${bbv_bbPath}tmp/";bb_display_msgColor "TASK==>_mc" "TASK: summary" "" "1" "1" "1";bb_display_msgColor "INFO-B-->_mc" "finished installing: ${yellow}${bbv_blockToInstall}${reset}" "" "1" "1" "1";bb_display_msgColor "INFO-B-->_mc" "for block help run:  ${b}${white}$ bb --block ${bbv_blockToInstall}${reset}" "" "1" "0" "2";else errMsg="no block with this name found or repository is empty";returnCode="1";callingMsg="bb_install_block";aof="true";bb_error_standard "${errMsg}" "${returnCode}" "${callingMsg}" "${aof}";fi;};bb_loop_until(){ func="${1}";retries="${2}";status="999";if [[ "${status}" != "0" ]];then retry=0;"${func}";status=${?};until [[ "${retry}" == "${retries}" ]];do if [[ "${status}" == "0" ]];then retry=$((retries-1));else "${func}";status="${?}";fi;((retry++));done;fi;printf "%s" "${status}";};bb_network_localIpMatch(){ ipToCheck=${1};command=$(ip addr|grep -wq "${ipToCheck}");if command;then printf "true";else printf "false";fi;};bb_os_getLocal(){ res=$(uname -a);if [[ "${res}" == *"Darwin"* ]];then res="Mac";elif [[ $"${res}" == *"Ubuntu"* ]];then res="Ubuntu";elif [[ "$(cat /etc/system-release-cpe)" == *"centos"* ]];then res="Centos";elif [[ "$(cat /etc/system-release-cpe)" == *"redhat"* ]];then res="Redhat";else res="Unrecognised";fi;printf "%s" "${res}";};bb_path_editTrailingSlash(){ STR="${1}";addOrRemove="${2}";length=${#STR};if [[ "${addOrRemove}" == "add" ]];then last_char=${STR:length-1:1};[[ $last_char != "/" ]]&&STR="$STR/";else [[ $last_char == "/" ]]&&STR=${STR:0:length-1};fi;printf "%s" "$STR";};bb_path_oneSlashOnly(){ path=${1};path=$(echo ${path//\}/\}/});path=$(echo ${path//\/\//\/});path=$(echo ${path//\/\//\/});printf "%s" ${path};};bb_pid_waitForPids(){ for p in $arrayPids;do if [[ "${p}" != "local" ]];then if wait $p;then result=$?;if [ "${result}" == "0" ];then arrayPidSuccess+=" ${p}";else arrayPidFail+=" ${p}";fi;else arrayPidFail+=" ${p}";fi;fi;done;};bb_scp_sendBashBlocksOnly(){ local remotePath="${connect_targetFolder}bash-blocks/";local sshConnect="-q -i ${connect_sshKeyLocal} ${connect_sshUser}@${connect_pubIp}";local sshCommand="mkdir -p ${remotePath}bb ${remotePath}servers";local scpConnect="-q -o LogLevel=QUIET -i ${connect_sshKeyLocal}";local remotePathScp="${connect_sshUser}@${connect_pubIp}:${remotePath}";ssh ${sshConnect} "${sshCommand}"&&scp ${scpConnect} -r "${bbv_bbPath}bb" "${remotePathScp}"&&scp ${scpConnect} -r "${bbv_bbPath}tmp/payload" "${remotePathScp}"&&scp ${scpConnect} -r "${bbv_bbPath}README.md" "${remotePathScp}"&&scp ${scpConnect} -r "${bbv_bbPath}blocks/${build_block}" "${remotePathScp}blocks/"&&scp ${scpConnect} -r "${bbv_bbPath}servers/${bbv_jsonServers}" "${remotePathScp}servers/";};bb_scp_sendThisBlockOnly(){ local thisBlock="${1}";local remotePath="${connect_targetFolder}bash-blocks/";local scpConnect="-q -o LogLevel=QUIET -i ${connect_sshKeyLocal}";local remotePathScp="${connect_sshUser}@${connect_pubIp}:${remotePath}";scp ${scpConnect} -r "${bbv_bbPath}blocks/${thisBlock}" "${remotePathScp}blocks/";};bb_scp_sendThisBlockSwareOnly(){ local thisBlock="${1}";local remotePath="${connect_targetFolder}bash-blocks/";local remoteSwareFolder="${remotePath}blocks/${build_block}/software/";local scpConnect="-q -o LogLevel=QUIET -i ${connect_sshKeyLocal}";local remotePathScp="${connect_sshUser}@${connect_pubIp}:${remotePath}";scp ${scpConnect} -r "${bbv_bbPath}blocks/${build_block}/software" "${remotePathScp}${remoteSwareFolder}";};bb_source_bb(){ files="$(find ${bbv_bbPath}framework/ -name "*.bash*" -not -path "*jq*" -not -path "*templates/*")";for file in $(printf "%s\n" "$files");do [ -f $file ]&&. $file;done;};bb_ssh_deployBlock(){ local cmd="chmod -R 755 ${connect_targetFolder}bash-blocks/bb && ${connect_targetFolder}bash-blocks/bb deployBlock ${bbv_jsonServers} ${connect_targetFolder} ${build_block} ${loopServerId}";if [[ "${bbv_default_debug}" == "true" ]];then bb_debug_thisVar "remote launch variables" "remote_os" "${remote_os}";bb_debug_thisVar "remote launch variables" "bbv_jsonServers" "${bbv_jsonServers}";bb_debug_thisVar "remote launch variables" "connect_targetFolder" "${connect_targetFolder}";bb_debug_thisVar "remote launch variables" "build_block" "${build_block}";bb_debug_thisVar "remote launch variables" "loopServerId" "${loopServerId}";ssh -ttq -o "BatchMode yes" -o "ForwardX11=no" ${connect_sshUser}@${connect_pubIp} "${cmd}";else ssh -ttq -o "BatchMode yes" -o "ForwardX11=no" -i ${connect_sshKeyLocal} ${connect_sshUser}@${connect_pubIp} "${cmd}">/dev/null 2>&1;fi;};bb_ssh_getSwareVersionFromPid(){ grepString=${1};grepDeleteAfter=${2};runningVersion=$(ssh -x -q -i ${connect_sshKeyLocal} ${connect_sshUser}@${connect_pubIp} "ps aux | grep -v grep | grep -v '\-p\ ${build_block}' | grep -v '\--block\ ${build_block}' | grep -v '\-b\ ${build_block}'");runningVersion=$(echo $runningVersion|grep -o "${grepString}[^ ]*"|sed "s/^\(${grepString}\)*//"|sed "s/${grepDeleteAfter}.*//"|grep -v 'java-[^ ]*'|head -1|sed 's/\/.*//');if [[ -z ${runningVersion} ]];then runningVersion="n/a";fi;printf "${runningVersion}";};bb_ssh_isSwareAvailable(){ retries=${1};testCommand=${2};testCommand="source ~/.bash_profile && ${testCommand}";status="999";if [[ "${status}" != "0" ]];then retry=0;until [[ "${retry}" == "${retries}" ]];do output=$(ssh -q -i ${connect_sshKeyLocal} ${connect_sshUser}@${connect_pubIp} "${testCommand}"&>/dev/null);status=$?;if [[ "${status}" == "0" ]];then result="${status}";break;else((retry++));fi;done;fi;printf "%s" "${result}";};bb_ssh_makeGenericBlockFolders(){ local remotePath="${connect_targetFolder}bash-blocks/";local sshConnect="-q -i ${connect_sshKeyLocal} ${connect_sshUser}@${connect_pubIp}";local sshCommand="mkdir -p ${remotePath}blocks ${remotePath}installed-blocks";ssh "${sshConnect}" "${sshCommand}";};bb_ssh_removeBashBlocksAll(){ local remotePath="${connect_targetFolder}bash-blocks/";local sshConnect="-q -o ForwardX11=no -i ${connect_sshKeyLocal} ${connect_sshUser}@${connect_pubIp}";local sshCommand="rm -rf ${remotePath}";ssh "${sshConnect}" "${sshCommand}";};bb_ssh_removeBashBlocksOnly(){ local remotePath="${connect_targetFolder}bash-blocks/";local sshConnect="-q -o ForwardX11=no -i ${connect_sshKeyLocal} ${connect_sshUser}@${connect_pubIp}";local sshCommand="rm -rf ${remotePath}bb ${remotePath}tmp ${remotePath}README.md ${remotePath}.gitignore ${remotePath}.git";ssh ${sshConnect} "${sshCommand}";};bb_ssh_removeThisBlock(){ local thisBlock="${1}";local remotePath="${connect_targetFolder}bash-blocks/";local sshConnect="-q -o ForwardX11=no -i ${connect_sshKeyLocal} ${connect_sshUser}@${connect_pubIp}";local sshCommand="rm -rf ${remotePath}blocks/${thisBlock} ${remotePath}blocks/installed-blocks/${thisblock} ${remotePath}tmp";ssh ${sshConnect} "${sshCommand}";};bb_ssh_removeThisBlockSwareOnly(){ local thisBlock="${1}";local remotePath="${connect_targetFolder}bash-blocks/";local sshConnect="-q -i ${connect_sshKeyLocal} ${connect_sshUser}@${connect_pubIp}";local sshCommand="rm -rf ${remotePath}blocks/${thisBlock}/software/*";ssh "${sshConnect}" "${sshCommand}";};bb_ssh_testWritePaths(){ connect_sshUser="${1}";connect_pubIp="${2}";connect_sshKeyLocal="${3}";retries="${4}";path="${5}";status="999";if [[ "${status}" != "0" ]];then retry=1;until [[ "${retry}" == "${retries}" ]]||[[ "${status}" == "0" ]];do remote_write=$(ssh -q -o ConnectTimeout=3 -i ${connect_sshKeyLocal} ${connect_sshUser}@${connect_pubIp} "mkdir -p ${path}"&>/dev/null);status=${?};if [[ "${status}" == "0" ]];then exit 0;else((retry++));fi;exit 1;done;fi;};bb_string_trimWhiteSpace(){ local var="$*";var="${var#"${var%%[![:space:]]*}"}";var="${var%"${var##*[![:space:]]}"}";printf "%s" "${var}";};bb_tidy_removeTmpFolder(){ rm -rf ${bbv_bbPath}tmp;};bb_time_blockRunDuration(){ block_end=$(date +%s);diff=$((block_end-script_start));};bb_time_timecount(){ min=0;sec=${1};message=${2};printf "%s\n" "${2}";while [ $min -ge 0 ];do while [[ $sec -ge 0 ]];do echo -ne "00:0$min:$sec\033[0K\r";sec=$((sec-1));sleep 1;done;sec=59;min=$((min-1));done;};bb_time_timestamp(){ date +%F_%T;};bb_array_printArray(){ local -n array=$1;bb_display_msgColor "INFO-B-->_mc" "displaying array" "${yellow}${!array}" "1" "1" "1";for i in ${!array[@]};do echo "${cyan}key is:    $i ${reset}";echo "value is:  ${array[$i]} ${reset}";done;};bb_debug_thisVar(){ local tag="${1}";local var="${2}";local val="${3}";printf "%s\n" "======================================================";bb_display_msgColor "INFO-B-->_mc" "${tag}:" "" "1" "1" "1";bb_display_equalSpacing "${var}:" "${val}" "$cyan" "$white" "0" "true";};bb_error_standard(){ errMsg="${1}";returnCode="${2}";callingMsg="${3}";aof="${4}";bb_display_msgColor "ERROR-->_mc" "Error:" "${b}${yellow}${errMsg}${reset}${b} --> return code: ${b}${yellow}${returnCode}${reset}${b} --> caught at: ${b}${yellow}${callingMsg}${reset}" "1" "1" "1";if [[ ${aof} == "true" ]];then bb_display_msgColor "INFO-B-->_mc" " stack trace:" "" "1" "" "1";for i in ${!FUNCNAME[@]};do echo "${cyan}key is:    $i ${reset}";echo "value is:  ${FUNCNAME[$i]} ${reset}";done;bb_tidy_removeTmpFolder;kill -s TERM $TOP_PID;fi;};bb_file_bbCodeTags(){ whichTag="${1}";tagBlock="${2}";tagLabel="${3}";timeStamp="$(bb_time_timestamp)";beginTag="\#>>>>>BASH_BLOCKS___block:${tagBlock}___label:${tagLabel}___BEGIN:${timeStamp}";endTag="\#>>>>>BASH_BLOCKS___block:${tagBlock}___label:${tagLabel}___END:${timeStamp}";if [[ ${whichTag} == "labelA" ]];then printf "%s" "${beginTag}";elif [[ ${whichTag} == "labelB" ]];then printf "%s" "${endTag}";fi;};bb_file_trailingSpaceRemove(){ local file="${1}";local lastString=$(bb_awk_opsFile "getString_lastNonEmptyLine" "${file}");local finish=$(bb_awk_opsFile "getLineNumber_last" "${file}");local lastStringLineNumber=$(bb_file_getLastLineNoToMatchString "${file}" "${finish}" "${lastString}");local start=${lastStringLineNumber};((start++));bb_check_doIf "${finish}" "-gt" "${start}" "bb_sed_file del_byLineNumberRange ${file} ${start} ${finish}";printf "${start}";};bb_folder_createFromDelimitedList(){ foldersToMake=${1};bb_array_stringDelimeter ";" "${foldersToMake}";for i in "${!arrayTmp[@]}";do value="${arrayTmp[$i]}";mkdir -p "${value}";done;};bb_folder_deserialiseFiles(){ local folderPath="${1}";local clearArray="${2}";if [[ -d ${folderPath} ]]&&[[ $(bb_folder_checkNotEmpty ${folderPath}) != "false" ]];then for filePath in ${folderPath}/*;do bb_file_deserialiseToArray "${filePath}" "${clearArray}";done;fi;};bb_help_bb(){ printf "%s\n" "${b}HELP                                          | flags                    | values [default]${reset}";printf "%s\n" "----------------------------------------------------------------------------------------------";bb_display_msgColor "TASK==>_mc" "Flags: bash-blocks" "" "2" "0" "1";printf "%s\n" "----------------------------------------------------------------------------------------------";printf "%s\n" ".. bash-blocks help + list installed blocks   | -h   --help              | n/a";printf "%s\n" ".. help for a given block                     | -b   --block             | block-abc";printf "%s\n" ".. specify json definition to use             | -s   --servers           | json-file-name";printf "%s\n" ".. enter debug mode for verbose messages      | -d   --debug             | [false] true";printf "%s\n" ".. specify pause between stages               | -ib  --installblock      | block-abc";printf "%s\n" ".. specify pause between stages               | -sp  --stagepause        | sec-as-int [5]";printf "%s\n" ".. abort on any job failure                   | -aof --abortonfail       |  false [true]";printf "%s\n" ".. make local build folder                    | -mbf --makebuildfolder   | [false] true edit";printf "%s\n" ".. scp block software files to servers        | -sbs --sendblocksware    |  false [true]";printf "%s\n" "----------------------------------------------------------------------------------------------";printf "%s\n" "${b}examples:${reset}";printf "%s\n" "${yellow}$ bb --help${reset}                                           //bash-blocks help + list installed blocks";printf "%s\n" "${yellow}$ bb --block block-abc${reset}                                //help for named block + list json defintions";printf "%s\n" "${yellow}$ bb -b block-abc -s preprod.json${reset}                     //use this block with this json";printf "%s\n" "${yellow}$ bb -b block-abc -s preprod.json -aof false -d true${reset}  //do not abort on fail and in debug mode";printf "%s\n" "----------------------------------------------------------------------------------------------";bb_tidy_removeTmpFolder;};bb_help_listBlockJson(){ if [[ "${bbv_switch_block}" != "true" ]];then bb_display_msgColor "TASK==>_mc" "Installed Blocks:" "" "0" "0" "1";availableBlocks=$(ls ${bbv_bbPath}blocks|grep -v "software"|grep -v "about.txt"|grep -v "block-template");printf "%s\n" ${availableBlocks};else bb_display_msgColor "TASK==>_mc" "json: file --> connectJson" "" "0" "0" "1";declare -a availableServers;availableServers=$(ls ${bbv_bbPath}blocks/${build_block}/servers_json/${bbv_jsonServers}|grep -v .template);for server in ${availableServers[@]};do buildJson=$(${jqCmd} -r '.build.connectJson' ${bbv_bbPath}blocks/${build_block}/servers_json/${bbv_jsonServers}/${server});if [[ "${buildJson}" == "" ]];then bb_display_equalSpacing "${server}" "inline" "${b}" "${reset}" "0" "true";else bb_display_equalSpacing "${server}" "${buildJson}" "${b}" "${reset}" "0" "true";fi;done;fi;printf "%s\n";};bb_java_getVersion(){ javaCheck=$(bb_ssh_isSwareAvailable "2" "java -version");if [[ "${javaCheck}" == "0" ]];then if [[ "${remote_os}" == "Mac" ]];then output=$(ssh -i ${connect_sshKeyLocal} ${connect_sshUser}@${connect_pubIp} "export JAVA_HOME=`/usr/libexec/java_home -v 1.8` && java -version" 2>&1);else output=$(ssh -i ${connect_sshKeyLocal} ${connect_sshUser}@${connect_pubIp} "java -version" 2>&1);fi;status=$?;if [[ "${status}" == "0" ]]&&[[ "${output}" != "" ]]&&[[ "${output}" != *"no jvm found"* ]];then version="${output}";elif [[ "${status}" == "0" ]]&&[[ "${output}" == *"no jvm found"* ]];then version="no jvm found";else version="java not installed";fi;else version="java not installed";fi;printf "%s" "${version}";};bb_json_displayPaths(){ key=${1};checkType=$(${jqCmd} -r '.servers.server'${loopServerId}'.'$key'|type' ${bbv_jsonServersPath} 2>/dev/null);checkValue=$(${jqCmd} -r '.servers.server'${loopServerId}'.'$key ${bbv_jsonServersPath} 2>/dev/null);if [[ ${checkType} == "string" ]];then writePath=$(${jqCmd} -r '.servers.server1.'$key'' ${bbv_jsonServersPath});writePath=$(bb_path_oneSlashOnly "${writePath}");printf "%s\n" ${writePath};elif [[ ${checkType} == "array" ]];then arrayJsonValues="$(${jqCmd} -r '.servers.server'${loopServerId}'.'$key'[]' ${bbv_jsonServersPath})";for checkValue in $arrayJsonValues;do checkValue=$(bb_path_oneSlashOnly "${checkValue}");printf "%s\n" ${checkValue};done;else parentElement=$(echo $key|sed "s/\..*//");childElement=$(echo $key|sed "s/.*\.//");checkType=$(${jqCmd} -r '.servers.server'${loopServerId}'.'${parentElement}'|type' ${bbv_jsonServersPath} 2>/dev/null);if [[ ${checkType} == "object" ]];then arrayObjectPaths=$(${jqCmd} -r '.servers.server'${loopServerId}'.'${parentElement}'|keys[]' ${bbv_jsonServersPath});for nestedElement in $arrayObjectPaths;do checkType=$(${jqCmd} -r '.servers.server'${loopServerId}'.'${parentElement}'.'${nestedElement}'.'${childElement}'|type' ${bbv_jsonServersPath} 2>/dev/null);if [[ ${checkType} == "array" ]];then key="${parentElement}.${nestedElement}.${childElement}";arrayJsonValues="$(${jqCmd} -r '.servers.server'${loopServerId}'.'$key'[]' ${bbv_jsonServersPath})";for checkValue in $arrayJsonValues;do checkValue=$(bb_path_oneSlashOnly "${checkValue}");printf "%s\n" ${checkValue};done;else checkValue=$(${jqCmd} -r '.servers.server'${loopServerId}'.'${parentElement}'.'${nestedElement}'.'${childElement} ${bbv_jsonServersPath});checkValue=$(bb_path_oneSlashOnly "${checkValue}");printf "%s\n" "${checkValue}";fi;done;else arrayTestWritePids["${key}"]="1;Bad entry for WRITETEST";fi;fi;};bb_loop_taskReport(){ taskTag="${1}";taskAllSuccessMsg="${2}";atLeastOneFailureFlag="false";for action in "${!arrayTaskActions[@]}";do if [[ ${arrayTaskActions["${action}"]} != "0" ]]&&[[ "${action}" == *"failure"* ]]&&[[ "${action}" == *"${taskTag}"* ]];then bb_display_msgColor "CROSS-->_mc" "failure:" "${action}" "1" "0" "1";atLeastOneFailureFlag="true";fi;done;if [[ ${atLeastOneFailureFlag} == "true" ]];then for action in "${!arrayTaskActions[@]}";do if [[ "${arrayTaskActions["${action}"]}" == "0" ]]&&[[ "${action}" == *"success"* ]]&&[[ "${action}" == *"${taskTag}"* ]];then bb_display_msgColor "TICK-->_mc" "success:" "${action}" "1" "0" "1";fi;done;else bb_display_msgColor "TICK-->_mc" "every server:" "${taskAllSuccessMsg}" "1" "0" "1";fi;};bb_pid_sendBlockSware(){ local thisBlock="${1}";bb_scp_sendThisBlockSwareOnly "${thisBlock}"& printf "${!}";};bb_pid_updateBashBlocksAndBlock(){ local thisBlock="${1}";bb_ssh_removeBashBlocksOnly&&bb_scp_sendBashBlocksOnly&&bb_ssh_removeThisBlock "${thisBlock}"&&bb_ssh_makeGenericBlockFolders&&bb_scp_sendThisBlockOnly "${thisBlock}"& printf "${!}";};bb_pid_updateBashBlocksOnly(){ bb_ssh_removeBashBlocksOnly&&bb_scp_sendBashBlocksOnly& printf "${!}";};bb_pid_updateBlockAndSware(){ local thisBlock="${1}";bb_ssh_removeThisBlock "${thisBlock}"&&bb_ssh_makeGenericBlockFolders&&bb_scp_sendThisBlockOnly "${thisBlock}"&&bb_scp_sendThisBlockSwareOnly "${thisBlock}"& printf "${!}";};bb_pid_updateBlockOnly(){ local thisBlock="${1}";bb_ssh_removeThisBlock "${thisBlock}"&&bb_ssh_makeGenericBlockFolders&&bb_scp_sendThisBlockOnly "${thisBlock}"& printf "${!}";};bb_report_currentTask(){ local thisFunc=${FUNCNAME[0]};local stage="${1}";local successMsg="${2}";useGenericPidFuncFlag="false";arrayTaskReportMessages[${stage}_taskReport]="";bb_display_msgColor "TASK==>_mc" "TASK: running report" "" "1" "2" "1";if [[ "${stage}" == "bb_STAGE_buildFolder_task" ]];then if [[ "$(echo ${bb_array_settings[bbv_buildFolderStageHasRun]})" == "true" ]];then bb_display_msgColor "TICK-->_mc" "local server:" "${successMsg}" "1" "0" "1";else successMsg="utilise existing build folder";bb_display_msgColor "TICK-->_mc" "local server:" "${successMsg}" "1" "0" "1";fi;elif [[ "${stage}" == "bb_STAGE_testSsh_task" ]];then useGenericPidFuncFlag="true";elif [[ "${stage}" == "bb_STAGE_testWritePaths_task" ]];then useGenericPidFuncFlag="true";elif [[ "${stage}" == "bb_STAGE_sendBashBlocks_task" ]];then if [[ $(echo ${bb_array_settings[bbv_existsRemoteServer]}) != "true" ]]&&[[ ${arrayPidFail} == "" ]];then successMsg="no need to send bash-blocks framework locally";bb_display_msgColor "TICK-->_mc" "local server:" "${successMsg}" "1" "0" "1";else useGenericPidFuncFlag="true";fi;elif [[ "${stage}" == "bb_STAGE_sendBlockSware_task" ]];then if [[ ${arrayPidFail} != "" ]];then useGenericPidFuncFlag="true";elif [[ "${block_default_sendBlockSware}" == "true" ]]&&[[ $(echo ${bb_array_settings[bbv_existsRemoteServer]}) != "true" ]];then successMsg="no need to send block resources locally";bb_display_msgColor "TICK-->_mc" "local server:" "${successMsg}" "1" "0" "1";elif [[ "${block_default_sendBlockSware}" != "true" ]];then successMsg="this stage has been skipped";bb_display_msgColor "TICK-->_mc" "local server:" "${successMsg}" "1" "0" "1";else useGenericPidFuncFlag="true";fi;elif [[ "${stage}" == "bb_STAGE_deployBlock_task" ]];then useGenericPidFuncFlag="true";else ${stage}_report;fi;if [[ "${useGenericPidFuncFlag}" == "true" ]];then if [[ ${arrayPidFail} != "" ]];then for f in ${arrayPidFail[@]};do bb_display_msgColor "CROSS-->_mc" "failure:" "${arrayPidDetails[$f]}" "1" "0" "1";arrayPidFailAllStages[$f]="${stage}";done;successMsg="fail";for s in ${arrayPidSuccess[@]};do bb_display_msgColor "TICK-->_mc" "success:" "${arrayPidDetails[$s]}" "1" "0" "1";done;else bb_display_msgColor "TICK-->_mc" "every server:" "${successMsg}" "1" "0" "1";fi;fi;arrayTaskReportMessages["${stage}_taskReport"]="${successMsg}";if [[ $(echo ${arrayTaskReportMessages["${stage}_taskReport"]}) == "fail" ]]&&[[ "${bbv_default_abortOnFail}" == "true" ]];then errMsg="${stage} has failed jobs (--abortonfail='true')";returnCode="1";callingMsg="${thisFunc}: line - ${LINENO}";bb_error_standard "${errMsg}" "${returnCode}" "${callingMsg}" "true";fi;};bb_report_finalStageSummary(){ for i in ${!arrayBlockStages[@]};do local order=${i};local thisStage=${arrayBlockStages[$i]};local atLeastOne="false";if [[ "${thisStage}" == "bb_STAGE_finalStage" ]];then bb_display_msgColor "TICK-->_mc" "stage ${order}/${noOfStages}:" "final stage summary (this stage!)" "1" "0" "1";bb_display_msgColor "TICK-->_mc" "${b}${cyan}final task:${reset}" "block ${b}${cyan}${build_block}${reset} final messages to follow here ...${reset}" "1" "0" "1";fi;for pid in ${!arrayPidFailAllStages[@]};do local stage="${arrayPidFailAllStages[$pid]}";if [[ "${stage}" == "${thisStage}_task" ]];then for p in ${!arrayPidDetails[@]};do if [[ "${pid}" == "${p}" ]];then local atLeastOne="true";break;fi;done;fi;done;if [[ "${atLeastOne}" == "true" ]];then bb_display_msgColor "CROSS-->_mc" "stage ${order}/${noOfStages}:" "failures encountered during stage ${b}${red}${thisStage}${reset}..." "1" "0" "2";for pid in ${!arrayPidFailAllStages[@]};do stage="${arrayPidFailAllStages[$pid]}";if [[ "${stage}" == "${thisStage}_task" ]];then for p in ${!arrayPidDetails[@]};do if [[ "${pid}" == "${p}" ]];then bb_display_msgColor "CROSS-->_mc" "-->" "${arrayPidDetails[$p]}" "1" "0" "1";local atLeastOneFlag="true";fi;done;if [[ "${atLeastOneFlag}" == "true" ]];then printf "\n";fi;fi;done;else for j in ${!arrayTaskReportMessages[@]};do taskReport=${j};taskReportMsg=${arrayTaskReportMessages[$j]};if [[ "${taskReport}" == "${thisStage}_task_taskReport" ]];then bb_display_msgColor "TICK-->_mc" "stage ${order}/${noOfStages}:" "${taskReportMsg}" "1" "0" "1";fi;done;fi;done;};bb_ssh_getRemoteOs(){ result=$(ssh -q -o Forwardx11=no -i ${connect_sshKeyLocal} ${connect_sshUser}@${connect_pubIp} "$(typeset -f bb_os_getLocal); bb_os_getLocal");printf "${result}";};bb_time_stageTimer(){ printf "%s\n";bb_time_timecount "${bbv_default_stagePause}" "continuing to next STAGE...";};bb_debug_bbLocalSetup(){ printf "%s\n" "======================================================";bb_display_msgColor "INFO-B-->_mc" "bb_array_settings:" "" "1" "1" "1";bb_array_printArray bb_array_settings;printf "%s\n" "======================================================";bb_display_msgColor "INFO-B-->_mc" "block_array_settings:" "" "1" "1" "1";bb_array_printArray block_array_settings;printf "%s\n" "======================================================";bb_display_msgColor "INFO-B-->_mc" "arrayJsonAllServers:" "" "1" "1" "1";bb_array_printArray arrayJsonAllServers;};bb_debug_blockLocalSetup(){ printf "%s\n" "======================================================";bb_display_msgColor "INFO-B-->_mc" "all bb and block settings:" "" "1" "1" "1";bb_array_printArray bb_array_settings;printf "%s\n" "======================================================";bb_display_msgColor "INFO-B-->_mc" "arrayBlockSoftware:" "" "1" "1" "1";bb_array_printArray arrayBlockSoftware;printf "%s\n" "======================================================";bb_display_msgColor "INFO-B-->_mc" "arrayWritetest:" "" "1" "1" "1";bb_array_printArray arrayWritetest;printf "%s\n" "======================================================";bb_display_msgColor "INFO-B-->_mc" "arrayWritetestNested:" "" "1" "1" "1";bb_array_printArray arrayWritetestNested;printf "%s\n" "======================================================";bb_display_msgColor "INFO-B-->_mc" "blockSwareFolder:" "" "1" "1" "1";bb_display_equalSpacing "blockSwareFolder:" "${blockSwareFolder}" "$cyan" "$white" "0" "true";};bb_debug_localLoop(){ printf "%s\n" "======================================================";bb_display_msgColor "INFO-B-->_mc" "loop settings:" "" "1" "1" "1";bb_display_equalSpacing "jsonFilePath:" "${jsonFilePath}" "$cyan" "$white" "0" "true";bb_display_equalSpacing "connect_targetFolder:" "${connect_targetFolder}" "$cyan" "$white" "0" "true";bb_display_equalSpacing "connect_installFolder:" "${connect_installFolder}" "$cyan" "$white" "0" "true";printf "%s\n" "======================================================";bb_display_msgColor "INFO-B-->_mc" "arrayJsonCurrentLoopServer:" "" "1" "1" "1";bb_array_printArray arrayJsonCurrentLoopServer;printf "%s\n" "======================================================";bb_display_msgColor "INFO-B-->_mc" "arrayPidFail:" "" "1" "1" "1";bb_array_printArray arrayPidFail;printf "%s\n" "======================================================";bb_display_msgColor "INFO-B-->_mc" "arrayPidSuccess:" "" "1" "1" "1";bb_array_printArray arrayPidSuccess;printf "%s\n" "======================================================";bb_display_msgColor "INFO-B-->_mc" "current loop server info:" "" "1" "1" "1";bb_display_equalSpacing "remote_os:" "${remote_os}" "$cyan" "$white" "0" "true";bb_display_equalSpacing "onServer:" "${onServer}" "$cyan" "$white" "0" "true";};bb_debug_remoteSetup(){ printf "%s\n" "======================================================";bb_display_msgColor "INFO-B-->_mc" "passed parameters:" "" "1" "1" "1";bb_display_equalSpacing "${bbv_os}:" "${bbv_os}" "$cyan" "$white" "0" "true";bb_display_equalSpacing "bbv_jsonServers:" "${bbv_jsonServers}" "$cyan" "$white" "0" "true";bb_display_equalSpacing "connect_targetFolder: " "${connect_targetFolder}" "$cyan" "$white" "0" "true";bb_display_equalSpacing "build_block:" "${build_block}" "$cyan" "$white" "0" "true";bb_display_equalSpacing "loopServerId:" "${loopServerId}" "$cyan" "$white" "0" "true";bb_display_equalSpacing "bbv_bbPath:" "${bbv_bbPath}" "$cyan" "$white" "0" "true";bb_display_equalSpacing "bbv_jsonServersPath:" "${bbv_jsonServersPath}" "$cyan" "$white" "0" "true";printf "%s\n" "======================================================";bb_display_msgColor "INFO-B-->_mc" "passed parameters:" "" "1" "1" "1";bb_display_equalSpacing "PATH:" "${PATH}" "$cyan" "$white" "0" "true";bb_display_equalSpacing "build_buildFolder:" "${build_buildFolder}" "$cyan" "$white" "0" "true";bb_display_equalSpacing "build_connectJson:" "${build_connectJson}" "$cyan" "$white" "0" "true";bb_display_equalSpacing "bbv_buildFolderPath:" "${bbv_buildFolderPath}" "$cyan" "$white" "0" "true";bb_display_equalSpacing "connect_JsonPath:" "${connect_JsonPath}" "$cyan" "$white" "0" "true";bb_display_msgColor "INFO-B-->_mc" "block default arrays:" "" "1" "1" "1";printf "%s\n" "======================================================";bb_display_msgColor "INFO-B-->_mc" "bb_array_settings:" "" "1" "1" "1";bb_array_printArray bb_array_settings;printf "%s\n" "======================================================";bb_display_msgColor "INFO-B-->_mc" "block_array_settings:" "" "1" "1" "1";bb_array_printArray block_array_settings;};bb_error_comparisonTest(){ callingMsg=${1};errMsg=${2};value=${3};test=${4};testAgainst=${5};abort=${6};if [ $value $test $testAgainst ];then bb_error_standard "${errMsg}" "1" "${callingMsg}" "${abort}";fi;};bb_error_isJqWellFormed(){ command=${1};errMsg=${2};callingMsg=${3};abort=${4};result=$(${command});returnCode=$?;if [[ $returnCode != 0 ]]||[[ $result == "" ]];then bb_error_standard "${errMsg}" "${returnCode}" "${callingMsg}" "${abort}";fi;};bb_filesFolders_fileFolderExists(){ errMsg=${1};callingMsg=${2};returnCode=${3};abort=${4};fullPath=${5};fileOrFolder=${6};checkThis=${7};listFolder="${fullPath##*/}";declare -a checks;i=0;for f in ${fullPath}/*;do checks[i++]="${f#*/${listFolder}/}";done;notFound="true";for((i=0;i<${#checks[@]};i++));do if [[ "${checkThis}" == "${checks[i]}" ]];then if [[ -d "${fullPath}/${checkThis}" ]]&&[[ $fileOrFolder == "folder" ]];then fileOrFolder="folder"&&notFound="false";break;elif [[ -f "${fullPath}/${checkThis}" ]]&&[[ $fileOrFolder == "file" ]];then fileOrFolder="file"&&notFound="false";break;fi;fi;done;if [[ "${notFound}" != "false" ]];then bb_error_standard "${errMsg}" "${returnCode}" "${callingMsg}" "${abort}";fi;};bb_flag_rules(){ thisFunc=${FUNCNAME[0]};errMsg_jsonDefinition="${yellow}--json${reset}";errMsg_buildBlock="${yellow}--block${reset}";errMsg_sendSoftware="${yellow}--sendblocksware${reset}";if [[ "${bbv_switch_json}" != "true" ]]&&[[ "${bbv_switch_block}" == "true" ]];then bb_switch_help="true";bb_display_bbBanner;bb_help_bb;block_help_block;bb_help_listBlockJson;exit 0;elif [[ "${bbv_switch_json}" != "true" ]]&&[[ "${bbv_switch_block}" != "true" ]];then bb_error_standard "must supply valid values for:${reset} ${errMsg_buildBlock} ${errMsg_jsonDefinition§}" "1" "${thisFunc}: line - ${LINENO}" "true";elif [[ ${bbv_switch_sendBlockSware} == "true" ]]&&[[ "${block_default_sendBlockSware}" != "true" ]]&&[[ "${block_default_sendBlockSware}" != "false" ]];then bb_error_standard "${errMsg_sendSoftware}" "1" "${thisFunc}: line - ${LINENO}" "true";fi;};bb_os_command(){ thisFunc=${FUNCNAME[0]};mac_cmd=${1};ubuntu_cmd=${2};centos_cmd=${3};redhat_cmd=${4};local res=$(bb_os_getLocal);IFS='%';if [[ "${res}" == "Mac" ]];then printf "%s" /usr/local/bin/${mac_cmd};elif [[ "${res}" == "Ubuntu" ]];then printf "%s" ${ubuntu_cmd};elif [[ "${res}" == "Centos" ]];then printf "%s" ${centos_cmd};elif [[ "${res}" == "Redhat" ]];then printf "%s" ${redhat_cmd};else errMsg="${res} not supported";returnCode="1";callingMsg="${thisFunc}: line - ${LINENO}";bb_error_standard "${errMsg}" "${returnCode}" "${callingMsg}" "true";fi;unset IFS;};bb_ssh_connectTest(){ thisFunc=${FUNCNAME[0]};thisPid=${!};connect_sshUser="${1}";connect_pubIp="${2}";connect_sshKeyLocal="${3}";retries="${4}";status="999";if [[ "${status}" != "0" ]];then retry=1;until [[ "${retry}" == "${retries}" ]]||[[ "${status}" == "0" ]];do remote_os=${thisPid}_$(ssh -q -o ConnectTimeout=3 ${connect_sshUser}@${connect_pubIp});status=${?};if [[ "${status}" == "0" ]];then exit 0;else((retry++));fi;if [[ "${bbv_default_abortOnFail}" == "true" ]];then bb_error_standard "cannot ssh to remote server" "1" "${thisFunc}: line - ${LINENO}" "${bbv_default_abortOnFail}";fi;exit 1;done;fi;};bb_ssh_getRemoteOsRetries(){ thisFunc=${FUNCNAME[0]};thisPid=${!};retries="${1}";status="999";if [[ "${status}" != "0" ]];then retry=1;until [[ "${retry}" == "${retries}" ]]||[[ "${status}" == "0" ]];do remote_os=$(bb_ssh_getRemoteOs);status=${?};if [[ "${status}" == "0" ]];then exit 0;else((retry++));fi;if [[ "${bbv_default_abortOnFail}" == "true" ]];then bb_error_standard "cannot determine remote ${bbv_os}" "1" "${thisFunc}: line - ${LINENO}" "${bbv_default_abortOnFail}";fi;exit 1;done;fi;};bb_array_insertThis(){ local lineNumber=${1};local file="${2}";local cmd=$(bb_os_command "gsed -i" "sed -i" "sed -i" "sed -i");arrayLength=${#arrayInsertThis[@]};for((i=0;i<"${arrayLength}";i++));do local value=$(printf "%s" "${arrayInsertThis[$i]}");${cmd} "${lineNumber}i\\${value}" "${file}";((lineNumber++));done;};bb_file_labelledCodeInsert(){ local lineNumber=${1};local file="${2}";local label="${3}";local cmd=$(bb_os_command "gsed -i" "sed -i" "sed -i" "sed -i");local labelA="\#>>>>>BASH_BLOCKS___block:${build_block}___label:${label}___BEGIN:";local labelB="\#>>>>>BASH_BLOCKS___block:${block}___label:${label}___END:";arrayLength=${#arrayInsertThis[@]};for((i=0;i<"${arrayLength}";i++));do local value=$(printf "%s" "${arrayInsertThis[$i]}");${cmd} "${lineNumber}i\\${value}" "${file}";((lineNumber++));done;};bb_file_setBufferAbove(){ local insertLine="${1}";local buffer="${2}";local file="${3}";local cmd=$(bb_os_command "gsed -i" "sed -i" "sed -i" "sed -i");for((i=0;i<"${buffer}";i++));do ${cmd} "${insertLine}i\\ " "${file}";done;};bb_file_setBufferBelow(){ local insertLine="${1}";local buffer="${2}";local file="${3}";local cmd=$(bb_os_command "gsed -i" "sed -i" "sed -i" "sed -i");for((i=0;i<"${buffer}";i++));do ${cmd} "${insertLine}i\\ " "${file}";((insertLine++));done;};bb_json_replaceVariables(){ before=${1};dynamic_cmd="$(bb_os_command 'gsed' 'sed' 'sed' 'sed')";after=$(echo ${before}|${dynamic_cmd} "s@\${connect_targetFolder}@${connect_targetFolder}@g"|${dynamic_cmd} "s@\${build_block}@${build_block}@g"|${dynamic_cmd} "s@\${connect_installFolder}@${connect_installFolder}@g");for i in ${!arrayJsonAllServers[@]};do if [[ "${i}" == *"build_"* ]];then prefix="\\$";firstBit="{${i}}";secondBit="${arrayJsonAllServers[$i]}";after=$(echo ${after}|${dynamic_cmd} "s@${prefix}${firstBit}@${secondBit}@g");fi;done;printf "%s" ${after};};bb_sed_file(){ local cmd=$(bb_os_command "gsed -i" "sed -i" "sed -i" "sed -i");if [[ "${1}" == "del_byLineNumber" ]];then ${cmd} "${3}d" "${2}";elif [[ "${1}" == "del_byLineNumberRange" ]];then ${cmd} "${3},${4}d" "${2}";elif [[ "${1}" == "del_lineBySubstring" ]];then ${cmd} "/${3}/d" "${2}";elif [[ "${1}" == "del_emptyLines" ]];then ${cmd} 'N;/^\n$/d;P;d;' "${2}";elif [[ "${1}" == "del_lastLine" ]];then ${cmd} '$ d' "${2}";elif [[ "${1}" == "del_leadingHashAndWhitespace" ]];then ${cmd} "/${3}/s/^#\s*//" "${2}";elif [[ "${1}" == "del_lineContentAfterSubstring" ]];then ${cmd} "s,${3}.*,${4}," "${2}";elif [[ "${1}" == "del_lineContentWithSubstring" ]];then ${cmd} "/${3}/,d" "${2}";elif [[ "${1}" == "del_linesWithOneLeadingSpace" ]];then ${cmd} '/^ $/d' "${2}";elif [[ "${1}" == "get_lineByLineNumber" ]];then sed "${3}q;d" "${2}";elif [[ "${1}" == "get_lineBySubstring" ]];then sed -n /"${3}"/= "${2}";elif [[ "${1}" == "set_afterSubstringPathFriendly" ]];then ${cmd} "s,\(${3}\s*\).*\$,\1${4}," "${2}";elif [[ "${1}" == "set_commentOutLineMatchSubstring" ]];then ${cmd} "/${3}/ s/^#*/#/" "${2}";elif [[ "${1}" == "set_replaceSubstringWith" ]];then ${cmd} "s,${3},${4},g" "${2}";fi;};bb_sed_free(){ local cmd=$(bb_os_command "gsed" "sed" "sed" "sed");local Z="";if [[ "${1}" == "del_leadingHashAndWhitespace" ]];then Z=$(echo ${2}|${cmd} "/${3}/s/^#\s*//");elif [[ "${1}" == "del_lineContentAfterSubstring" ]];then Z=$(echo ${2}|${cmd} "s,${3}.*,${4},");elif [[ "${1}" == "del_lineContentWithSubstring" ]];then Z=$(echo ${2}|${cmd} "/${3}/,d");elif [[ "${1}" == "set_afterSubstringPathFriendly" ]];then Z=$(echo ${2}|${cmd} "s,\(${3}\s*\).*\$,\1${4},");elif [[ "${1}" == "set_replaceSubstringWith" ]];then Z=$(echo ${2}|${cmd} "s,${3},${4},g");fi;printf "${Z}";};bb_source_block(){ thisFunc="${FUNCNAME[0]}";bb_filesFolders_fileFolderExists "block does not exist" "${thisFunc}: line - ${LINENO}" "1" "true" "${bbv_bbPath}blocks/" "folder" "${build_block}";files=$(find ${bbv_bbPath}blocks/${build_block}/${build_block} -name "*.bash");for file in $(printf "%s\n" "$files");do [ -f $file ]&&. $file;done;chmod -R 700 "${bbv_bbPath}blocks/${build_block}/software/";};bb_array_lookup(){ jsonSetting=${1};serverId=${2};if [[ "${serverId}" != "all" ]];then this="servers_server${serverId}_${jsonSetting}";else this="${jsonSetting}";fi;value="${arrayJsonAllServers[${this}]}";value=$(bb_json_replaceVariables "${value}");printf "%s" "${value}";};bb_file_emptyLinesRemove(){ local file="${1}";local mode="${2}";local lineNumber="${3}";local lineContents=$(bb_sed_file "get_lineByLineNumber" "${file}" "${lineNumber}");local lineLessSpace=$(echo ${lineContents//[[:space:]]/});local lineSize=$(echo ${#lineLessSpace});local lastLineNumber=$(bb_awk_opsFile "getLineNumber_last" "${file}");if [[ "${mode}" == "below" ]];then while [[ ${lineSize} == "0" ]]&&[[ "${lineNumber}" -le "${lastLineNumber}" ]]&&[[ "${lineNumber}" -gt "0" ]];do bb_sed_file "del_byLineNumber" "${file}" "${lineNumber}";lineContents=$(bb_sed_file "get_lineByLineNumber" "${file}" "${lineNumber}");lineLessSpace=$(echo ${lineContents//[[:space:]]/});lineSize=$(echo ${#lineLessSpace});lastLineNumber=$(bb_awk_opsFile "getLineNumber_last" "${file}");done;elif [[ "${mode}" == "above" ]];then while [[ ${lineSize} == "0" ]]&&[[ "${lineNumber}" -gt "0" ]];do bb_sed_file "del_byLineNumber" "${file}" "${lineNumber}";((lineNumber--));lineContents=$(bb_sed_file "get_lineByLineNumber" "${file}" "${lineNumber}");lineLessSpace=$(echo ${lineContents//[[:space:]]/});lineSize=$(echo ${#lineLessSpace});done;printf "%s" "${lineNumber}";fi;};bb_json_lookup(){ lookupValue=${1};lookupType=${2};if [[ ${lookupType} == "type" ]];then result=$(${jqCmd} -r "${lookupValue} | type" ${bbv_jsonServersPath} 2>/dev/null);elif [[ ${lookupType} == "array" ]];then result=$(${jqCmd} -r "${lookupValue}[]" ${bbv_jsonServersPath} 2>/dev/null);elif [[ ${lookupType} == "keys" ]];then result=$(${jqCmd} -r "${lookupValue} | keys[]" ${bbv_jsonServersPath} 2>/dev/null);elif [[ ${lookupType} == "paths" ]];then result=$(${jqCmd} -r "${lookupValue} | paths[]" ${bbv_jsonServersPath} 2>/dev/null);elif [[ ${lookupType} == "value" ]];then result=$(${jqCmd} -r "${lookupValue}" ${bbv_jsonServersPath} 2>/dev/null);else printf "%s\n" "This value is not allowed";fi;result=$(bb_json_replaceVariables ${result});printf "%s" ${result};};bb_json_recursiveArrays(){ if [[ "${1}" != "recursive" ]];then whichServers="${1}";jsonPath="${2}";if [[ "${whichServers}" == "all" ]];then generation="1";arrayGenerationParents[${generation}]="_";keys=$(${jqCmd} -r '.|keys[]' ${jsonPath});arrayParentsChildren["_"]="$keys";elif [[ "${whichServers}" == "build" ]];then generation="1";arrayGenerationParents[${generation}]="_build";keys=$(${jqCmd} -r '.build|keys[]' ${jsonPath});arrayParentsChildren["_build"]="$keys";else generation="1";arrayGenerationParents[${generation}]="_servers_server${whichServers}";whichServersJson=$(bb_sed_free "set_replaceSubstringWith" "${whichServers}" "_" ".");keys=$(${jqCmd} -r '.servers.server'${whichServersJson}'|keys[]' ${jsonPath});arrayParentsChildren["_servers_server${whichServers}"]="$keys";fi;fi;for k in $(seq ${generation} ${generation});do bString=${arrayGenerationParents[$k]};jqString=$(bb_sed_free "set_replaceSubstringWith" "${bString}" "_" ".");children=${arrayParentsChildren[${bString}]};if [[ "${jqString}" == "." ]];then bString="";jqString="";fi;for child in ${children};do jqStringChild=".${child}";bStringChild="_${child}";jqStringFull="${jqString}${jqStringChild}";bStringKey="${bString}${bStringChild}";bStringKeyCurrentServer=$(bb_sed_free "set_replaceSubstringWith" "${bStringKey}" "_servers_server._*" "");bStringKeyCurrentServer=$(bb_sed_free "set_replaceSubstringWith" "${bStringKeyCurrentServer}" "^_" "");bStringKeyCurrentServer=$(bb_string_trimWhiteSpace ${bStringKeyCurrentServer});bStringKeyAllServers=$(bb_sed_free "set_replaceSubstringWith" "${bStringKey}" "^_" "");bStringKeyAllServers=$(bb_string_trimWhiteSpace ${bStringKeyAllServers});nestedChildren=$(${jqCmd} -r ''${jqStringFull}'|keys[]' ${jsonPath} 2>/dev/null);nestedChildrenStatus=$?;checkHasValue=$(${jqCmd} -r ''${jqStringFull}'' ${jsonPath} 2>/dev/null);checkArrayResponse=$(printf "${checkHasValue//[[:space:]]/}");checkChildType=$(${jqCmd} -r ''${jqStringFull}'|type' ${jsonPath} 2>/dev/null);checkChildTypeStatus=$?;if [[ ${nestedChildrenStatus} != "0" ]]&&[[ ${checkHasValue} != "null" ]]&&[[ ${checkChildType} != "array" ]]&&[[ ${checkChildTypeStatus} == "0" ]];then result="$(${jqCmd} -r ''${jqStringFull}'' ${jsonPath})";result=$(bb_json_replaceVariables ${result});if [[ "${jqStringFull}" == *".connect.installFolder"* ]]||[[ "${jqStringFull}" == *".connect.targetFolder"* ]];then result=$(bb_path_oneSlashOnly ${result});fi;if [[ "${whichServers}" != "all" ]];then arrayJsonCurrentLoopServer["${bStringKeyCurrentServer}"]="${result}";fi;arrayJsonAllServers["${bStringKeyAllServers}"]="${result}";elif [[ ${nestedChildrenStatus} == "0" ]]&&[[ ${checkChildType} == "array" ]]&&[[ ${checkHasValue} != "[]" ]]&&[[ ${checkArrayResponse} != "null" ]];then result=$(echo ${checkArrayResponse}|tr -d "\]\""|tr -d "\'[");result=$(bb_json_replaceVariables ${result});if [[ "${jqStringFull}" == *".connect.installFolder"* ]]||[[ "${jqStringFull}" == *".connect.targetFolder"* ]];then result=$(bb_path_oneSlashOnly ${result});fi;if [[ "${whichServers}" != "all" ]];then arrayJsonCurrentLoopServer["${bStringKeyCurrentServer}"]="${result}";fi;arrayJsonAllServers["${bStringKeyAllServers}"]="${result}";else((generation++));arrayGenerationParents[${generation}]="${bStringKey}";arrayParentsChildren["${bStringKey}"]="${nestedChildren}";bb_json_recursiveArrays "recursive";fi;done;fullParentalLineage=${arrayGenerationParents[${generation}]};currentDescendent=${fullParentalLineage##*_};bString=${fullParentalLineage%_*};jqString=$(bb_sed_free "set_replaceSubstringWith" "${bString}" "_" ".");((generation--));done;};bb_path_getUnresolvedPath(){ before=${1};before=$(bb_path_oneSlashOnly ${before});after=$(bb_sed_free "set_replaceSubstringWith" "${before}" "${connect_installFolder}" "\${connect_installFolder}");if [[ "${after}" == "${before}" ]];then after=$(bb_sed_free "set_replaceSubstringWith" "${before}" "${connect_targetFolder}" "\${connect_targetFolder}");fi;printf "%s" "${after}";};bb_path_resolveArray(){ key=${1};multipleValuesFlag="false";arrayJsonValues="$(${jqCmd} -r '.servers.server'${loopServerId}'.'$key'[]' ${bbv_jsonServersPath})";for checkValue in $arrayJsonValues;do checkValue=$(bb_json_replaceVariables ${checkValue});if [[ ${multipleValuesFlag} == "true" ]];then printThis="${printThis};${checkValue}";else printThis="${checkValue}";multipleValuesFlag="true";fi;done;printf "${printThis}";};bb_array_declareJsonPaths(){ for key in "${!arrayJsonCurrentLoopServer[@]}";do for k in "${!arrayWritetestNested[@]}";do numberOfNests=$(grep -o "$*_"<<<"${k}"|wc -l);compare=$(printf "%s" "${k//\*}");keyCompare=$(printf "%s" "${key//[[:digit:]]/}");if [[ "${numberOfNests}" -eq "0" ]]&&[[ "${arrayJsonCurrentLoopServer[$k]}" != "" ]]||[[ "${numberOfNests}" -ne "0" ]]&&[[ "${compare}" == "${keyCompare}" ]];then partiallyResolvedPath="$(bb_path_getUnresolvedPath ${arrayJsonCurrentLoopServer[$key]})";arrayJsonPathsPartiallyResolved[${key}]="${partiallyResolvedPath}";arrayJsonPathsResolved[${key}]="${arrayJsonCurrentLoopServer[$key]}";fi;done;done;};bb_file_bufferedCodeInsert(){ local file="${1}";local insertLine="${2}";local buffer="${3}";local lineAboveInsertLine=${insertLine};((lineAboveInsertLine--));bb_array_insertThis "${insertLine}" "${file}";local newLineAboveInsertLine=$(bb_file_emptyLinesRemove "${file}" "above" "${lineAboveInsertLine}");local deleteCount=$(echo $((lineAboveInsertLine-newLineAboveInsertLine)));local initialBufferLine=${newLineAboveInsertLine};((initialBufferLine++));bb_file_setBufferAbove "${initialBufferLine}" "${buffer}" "${file}";arrayLength=${#arrayInsertThis[@]};local newInsertLine=$(echo $((insertLine+arrayLength+buffer-deleteCount)));bb_file_emptyLinesRemove "${file}" "below" "${newInsertLine}";bb_file_setBufferAbove "${newInsertLine}" "${buffer}" "${file}";};bb_file_labelledCodeRemove(){ local file="${1}";local thisBlock="${2}";local label="${3}";local labelA="\#>>>>>BASH_BLOCKS___block:${thisBlock}___label:${label}___BEGIN:";local labelB="\#>>>>>BASH_BLOCKS___block:${thisBlock}___label:${label}___END:";local lineStart=$(bb_sed_file "get_lineBySubstring" "${file}" "${labelA}");local lineEnd=$(bb_sed_file "get_lineBySubstring" "${file}" "${labelB}");if [[ ${lineStart} != "" ]]&&[[ ${lineEnd} != "" ]]&&[[ ${lineStart} -gt "0" ]];then bb_sed_file "del_byLineNumberRange" "${file}" "${lineStart}" "${lineEnd}";bb_file_emptyLinesRemove "${file}" "above" "${lineStart}";if [[ "${lineStart}" -gt "1" ]];then((lineStart--));fi;bb_file_emptyLinesRemove "${file}" "below" "${lineStart}";fi;};bb_loop_servers(){ local loopStage="${1}";local successMsg="${2}";local handlePids="${3}";for loopServerId in $(seq 1 ${bbv_numberOfServers});do if [[ "${build_connectJson}" != "" ]];then jsonFilePath="${bbv_connectJsonPath}";else jsonFilePath="${bbv_jsonServersPath}";fi;connect_targetFolder=$(${jqCmd} -r '.servers.server'${loopServerId}'.connect.targetFolder' ${jsonFilePath});connect_installFolder=$(${jqCmd} -r '.servers.server'${loopServerId}'.connect.installFolder' ${jsonFilePath});connect_targetFolder=$(bb_json_replaceVariables ${connect_targetFolder});connect_installFolder=$(bb_json_replaceVariables ${connect_installFolder});unset arrayJsonCurrentLoopServer;declare -A arrayJsonCurrentLoopServer;bb_json_recursiveArrays "${loopServerId}_connect" "${jsonFilePath}";bb_array_declareJsonCurrentLoopServer;if [[ "${bbv_remoteMode}" == "" ]];then remote_os=$(bb_ssh_getRemoteOs);onServer="${yellow}${connect_sshUser}@${connect_pubIp}${reset} with tag ${yellow}${connect_tag}${reset} on os ${yellow}${remote_os}${reset}";fi;if [[ "${bbv_default_debug}" == "true" ]];then bb_debug_localLoop;fi;${loopStage};done;if [[ "${handlePids}" == "true" ]];then printf "%s" ${red};bb_pid_waitForPids;printf "%s" ${reset};fi;bb_report_currentTask "${loopStage}" "${successMsg}" "${blockReport}";unset arrayPidFail;unset arrayPidSuccess;unset arrayPids;};bb_path_resolveObject(){ key=${1};multipleValuesFlag="false";arrayObjectPaths=$(${jqCmd} -r '.servers.server'${loopServerId}'.'${parentElement}'|keys[]' ${bbv_jsonServersPath});for nestedElement in $arrayObjectPaths;do checkType=$(${jqCmd} -r '.servers.server'${loopServerId}'.'${parentElement}'.'${nestedElement}'.'${childElement}'|type' ${bbv_jsonServersPath} 2>/dev/null);if [[ ${checkType} == "array" ]];then bb_path_resolveArray "${parentElement}.${nestedElement}.${childElement}";else checkValue=$(${jqCmd} -r '.servers.server'${loopServerId}'.'${parentElement}'.'${nestedElement}'.'${childElement} ${bbv_jsonServersPath});checkValue=$(bb_json_replaceVariables ${checkValue});if [[ ${multipleValuesFlag} == "true" ]];then printThis="${printThis};${checkValue}";else printThis="${checkValue}";multipleValuesFlag="true";fi;fi;done;printf "${printThis}";};bb_file_codeInsert(){ thisFunc="${FUNCNAME[0]}";local file="${1}";local action="${2}";local buffer="${3}";local lastLine="";local insertLine="";local errMsg="";lastLine=$(bb_file_trailingSpaceRemove "${file}");if [[ ${action} == "append" ]];then printf "\n\n">>"${file}";((lastLine++));insertLine="${lastLine}";elif [[ ${action} == "clear" ]];then rm -rf "${file}"&&touch "${file}"&&chmod 755 "${file}";printf "\n\n">>"${file}";insertLine="1";elif [[ "${action}" =~ ^-?[0-9]+$ ]];then insertLine="${action}";else errMsg="badly formed line or buffer parameter ${FUNCNAME[0]}";bb_error_standard "${errMsg}" "1" "${thisFunc}: line - ${LINENO}" "${bbv_default_abortOnFail}";fi;bb_file_bufferedCodeInsert "${file}" "${insertLine}" "${buffer}";lastLine=$(bb_file_trailingSpaceRemove "${file}");printf "%s" "${lastLine}";};bb_json_resolvePaths(){ key=${1};checkType=$(${jqCmd} -r '.servers.server'${loopServerId}'.'$key'|type' ${bbv_jsonServersPath} 2>/dev/null);checkValue=$(${jqCmd} -r '.servers.server'${loopServerId}'.'$key ${bbv_jsonServersPath} 2>/dev/null);checkValue=$(bb_json_replaceVariables ${checkValue});if [[ ${checkType} == "string" ]];then printf "${checkValue}";elif [[ ${checkType} == "array" ]];then bb_path_resolveArray "${key}";else parentElement=$(echo $key|sed "s/\..*//");childElement=$(echo $key|sed "s/.*\.//");checkType=$(${jqCmd} -r '.servers.server'${loopServerId}'.'${parentElement}'|type' ${bbv_jsonServersPath} 2>/dev/null);if [[ ${checkType} == "object" ]];then bb_path_resolveObject;else arrayTestWritePids["${key}"]="1;Bad entry for JSONPATHS_WRITETEST";fi;fi;};bb_ssh_removeLabelledConfigs(){ local file="${1}";local calculateHome="${2}";local thisBlock="${3}";local label="${4}";local funcsToExport="bb_file_labelledCodeRemove bb_sed_file bb_os_command bb_file_emptyLinesRemove bb_awk_opsFile bb_tidy_removeTmpFolder";local sshConnect="-q -o Forwardx11=no ${connect_sshUser}@${connect_pubIp}";local home="";if [[ "${calculateHome}" == "true" ]];then if [[ "${remote_os}" == "Mac" ]];then home="/Users/${connect_sshUser}/";else home="/home/${connect_sshUser}/";fi;fi;ssh -${sshConnect} "$(typeset -f ${funcsToExport}); ${bbv_os}=${remote_os} && bb_file_labelledCodeRemove ${home}${file} ${thisBlock} ${label}";};bb_bash_configDebian(){ file="${HOME}/.bashrc";touch ${file};label="source_bash_rc";bb_file_labelledCodeRemove "${file}" "bb" "${label}";labelA=$(bb_file_bbCodeTags "labelA" "bb" "${label}");labelB=$(bb_file_bbCodeTags "labelB" "bb" "${label}");unset arrayInsertThis;declare -a arrayInsertThis;arrayInsertThis[0]="${labelA}";arrayInsertThis[1]="if [ -r ~/.bash_profile ]; then source ~/.bash_profile; fi";arrayInsertThis[2]="${labelB}";insertFile="${file}";insertAction="append";result=$(bb_file_codeInsert "${insertFile}" "${insertAction}" "1");};bb_bash_configProfile(){ programHome=$(tr [:lower:] [:upper:]<<<"${1}");executablePath="${2}";block="${3}";file="${HOME}/.bash_profile";touch "${file}";bb_sed_file "del_lineBySubstring" "${file}" "export ${programHome}=";bb_sed_file "del_lineBySubstring" "${file}" "export PATH=\$${programHome}:\$PATH";bb_sed_file "del_lineBySubstring" "${file}" "export PATH=\$PATH:\$${programHome}";label="${programHome}_bash_profile";bb_file_labelledCodeRemove "${file}" "${block}" "${label}";labelA=$(bb_file_bbCodeTags "labelA" "${block}" "${label}");labelB=$(bb_file_bbCodeTags "labelB" "${block}" "${label}");unset arrayInsertThis;declare -a arrayInsertThis;if [ "${block}" == "bb" ];then arrayInsertThis[0]="${labelA}";arrayInsertThis[1]="export ${programHome}=${executablePath}";arrayInsertThis[2]="export PATH=\$${programHome}:\$PATH";arrayInsertThis[3]="alias fbb='cd ${bbv_bbPath}'";arrayInsertThis[4]="${labelB}";else arrayInsertThis[0]="${labelA}";arrayInsertThis[1]="export ${programHome}=${executablePath}";arrayInsertThis[2]="export PATH=\$${programHome}:\$PATH";arrayInsertThis[3]="${labelB}";fi;insertFile="${file}";insertAction="append";result=$(bb_file_codeInsert "${insertFile}" "${insertAction}" "1");};bb_pid_removeBashBlocksAll(){ bb_ssh_removeLabelledConfigs ".bash_profile" "true" "bb" "BB_HOME_bash_profile"&&bb_ssh_removeLabelledConfigs ".bashrc" "true" "bb" "source_bash_rc"&&bb_ssh_removeBashBlocksAll& printf "${!}";};bb_STAGE_buildFolder(){ local stageNumber="${1}";local stageTotal="${2}";bb_display_bbBanner "prepare build folder" "run locally" "${stageNumber}" "${stageTotal}";if [[ -d ${bbv_buildFolderPath}${buildSwareFolderSubFolderPath} ]]&&[[ "${block_default_makeBuildFolder}" == "false" ]];then bb_display_msgColor "ALERT-->_mc" "skipping stage:" "a build folder ${cyan} ${build_buildFolder}${reset}${b} already exists!" "1" "1" "0";bb_report_currentTask "bb_STAGE_buildFolder_task" "prepare build folder";else bb_loop_servers "bb_STAGE_buildFolder_task" "new build folder completed" "false";fi;bb_time_stageTimer;};bb_STAGE_buildFolder_task(){ bb_array_settings["bbv_buildFolderStageHasRun"]="true";sourceResourcesFolderPath="${bbv_bbPath}tmp/${buildSwareFolder}/${buildSwareFolderSubFolderPath}/";dseFileTar="${bbv_targetFolder_hostMachine}bash-blocks/blocks/${build_block}/software/${buildSware}";if [ -d "${bbv_buildFolderPath}${buildSwareFolderSubFolderPath}" ];then bb_display_msgColor "TASK==>_mc" "TASK: delete existing build folder" "" "1" "1" "1";bb_display_msgColor "ALERT-->_mc" "folder to be deleted" "${build_buildFolder}/${buildSwareFolderSubFolderPath}" "1" "1" "1";bb_display_msgColor "ALERT-->_mc" "are you sure?" "hit <ctrl-c> to abort now!" "2" "0" "2";bb_time_timecount "10" "..time left to exit!";rm -rf ${bbv_buildFolderPath}${buildSwareFolderSubFolderPath};bb_display_bbBanner "prepare build folder" "run locally" "${stageNumber}" "${stageTotal}";fi;bb_display_msgColor "TASK==>_mc" "TASK: unpack tar and strip out all non config files" "" "1" "1" "1";bb_display_msgColor "INFO-B-->_mc" "unpack from:" "${dseFileTar}" "1" "0" "1";bb_display_msgColor "INFO-B-->_mc" "unpack to:" "${bbv_buildFolderPath}${buildSwareFolderSubFolderPath}" "2" "0" "1";mkdir -p "${bbv_bbPath}tmp";tar -xf "${dseFileTar}" -C "${bbv_bbPath}tmp/";printf "\n%s\t%s\t%s\n" "${b}Extension |" "No. of files |" "Bytes${reset}";printf "%s\n" "-------------------------------------------";before_size=$(du -sh "${sourceResourcesFolderPath}"|awk '{ print $1 }');for i in "${arrayStripExtensions[@]}";do amount=$(find ${sourceResourcesFolderPath} -name "*.${i}" -type f -print|wc -l);size=$(find ${sourceResourcesFolderPath} -name "*.${i}" -type f -print|xargs wc -c|awk 'END { print $1 }');printf "%s\t%s\t%s\t%s\n" "${yellow}*.${i}${reset}" "  |" "${amount}     |" "${size}";find ${sourceResourcesFolderPath} -name "*.${i}" -type f -delete;done;printf "%s\n" "-------------------------------------------";printf "%s\t\t\t%s\n" "${b}Folder size before:" "${before_size}";printf "%s\t\t\t%s\n" "${b}Folder size after:" "$(du -sh ${sourceResourcesFolderPath}|awk '{ print $1 }')${reset}";bb_display_msgColor "TASK==>_mc" "TASK: copy stripped build folder into block" "" "1" "1" "1";bb_display_msgColor "INFO-B-->_mc" "move from:" "${sourceResourcesFolderPath}" "1" "0" "1";bb_display_msgColor "INFO-B-->_mc" "move to:" "${bbv_buildFolderPath}${buildSwareFolderSubFolderPath}" "1" "0" "0";cp -rp ${sourceResourcesFolderPath} ${bbv_buildFolderPath}${buildSwareFolderSubFolderPath} 2>/dev/null;rm -rf ${bbv_bbPath}tmp/${buildSwareFolder};if [[ "${block_default_makeBuildFolder}" == "edit" ]];then bb_display_msgColor "ALERT-->_mc" "edit mode - now exiting:" "folder can be found at: ${bbv_buildFolderPath}${buildSwareFolderSubFolderPath}" "1" "2" "1";bb_tidy_removeTmpFolder;exit 0;fi;};bb_STAGE_deployBlock(){ stageNumber="${1}";stageTotal="${2}";bb_display_bbBanner "install block remotely" "asynchronous" "${stageNumber}" "${stageTotal}";bb_loop_servers "bb_STAGE_deployBlock_task" "block deployment completed" "true";bb_time_stageTimer;};bb_STAGE_deployBlock_task(){ bb_display_msgColor "TASK==>_mc" "TASK: deploy block ${yellow}${build_block}${cyan} on servers" "" "1" "1" "1";bb_display_msgColor "INFO-B-->_mc" "on server:" "${onServer} with pid " "2" "0" "0";bb_ssh_deployBlock& pid=${!};printf "%s" "${cyan}$pid${reset}";details="${onServer} with pid ${cyan}$pid${reset}";arrayPidDetails["${pid}"]="${details}";arrayPids+=" $pid";};bb_STAGE_finalStage(){ stageNumber="${1}";stageTotal="${2}";bb_display_bbBanner "all stage summary" "run locally" "${stageNumber}" "${stageTotal}";bb_display_msgColor "TASK==>_mc" "TASK: final report on all stages" "" "1" "1" "1";bb_report_finalStageSummary;};bb_STAGE_sendBashBlocks(){ stageNumber="${1}";stageTotal="${2}";bb_display_bbBanner "distribute bash-blocks framework" "asynchronous" "${stageNumber}" "${stageTotal}";bb_loop_servers "bb_STAGE_sendBashBlocks_task" "bash-blocks and block ${build_block} code distributed" "true";bb_time_stageTimer;};bb_STAGE_sendBashBlocks_task(){ bb_display_msgColor "TASK==>_mc" "TASK: distribute bash-blocks framework" "" "1" "1" "1";bb_display_msgColor "INFO-B-->_mc" "on server:" "${onServer}" "2" "0" "0";localServer=$(bb_network_localIpMatch "${connect_pubIp}");if [[ "${localServer}" == "false" ]];then pid=$(bb_pid_updateBashBlocksAndBlock);details="${onServer} with pid ${cyan}${pid}${reset}";arrayPidDetails["${pid}"]="${details}";arrayPids+=" ${pid}";bb_array_settings[bbv_existsRemoteServer]="true";else pid="local";details="${onServer} - local so skip task";fi;arrayPidDetails["${pid}"]="${details}";arrayPids+=" ${pid}";};bb_STAGE_sendBlockSware(){ stageNumber="${1}";stageTotal="${2}";bb_display_bbBanner "distribute block ${build_block} resources" "asynchronous" "${stageNumber}" "${stageTotal}";bb_loop_servers "bb_STAGE_sendBlockSware_task" "block ${yellow}${build_block}${reset} software distributed" "true";bb_time_stageTimer;};bb_STAGE_sendBlockSware_task(){ if [[ "${block_default_sendBlockSware}" == "true" ]];then bb_display_msgColor "TASK==>_mc" "TASK: distribute block ${build_block} files" "" "1" "1" "1";bb_display_msgColor "INFO-B-->_mc" "on server:" "${onServer}" "2" "0" "0";if [[ "${localServer}" == "false" ]];then pid=$(bb_pid_sendBlockSware ${build_block});details="${onServer} with pid ${cyan}${pid}${reset}";arrayPidDetails["${pid}"]="${details}";arrayPids+=" ${pid}";else pid="local";details="${onServer} - local so skip task";arrayPidDetails["${pid}"]="${details}";arrayPids+=" ${pid}";fi;fi;};bb_STAGE_testSsh(){ stageNumber="${1}";stageTotal="${2}";bb_display_bbBanner "test connectivity" "asynchronous" "${stageNumber}" "${stageTotal}";bb_loop_servers "bb_STAGE_testSsh_task" "ssh connectivity test completed" "true";bb_time_stageTimer;};bb_STAGE_testSsh_task(){ bb_display_msgColor "TASK==>_mc" "TASK: test ssh connectivity" "" "1" "1" "1";bb_display_msgColor "INFO-B-->_mc" "on server:" "${onServer} with pid " "2" "0" "0";bb_ssh_connectTest "${connect_sshUser}" "${connect_pubIp}" "${connect_sshKeyLocal}" "3"& pid=${!};printf "%s" "${cyan}$pid${reset}";details="${onServer} with pid ${cyan}$pid${reset} --> ssh connect test";arrayPidDetails["${pid}"]="${details}";arrayPids+=" $pid";};bb_STAGE_testWritePaths(){ stageNumber="${1}";stageTotal="${2}";bb_display_bbBanner "test block write-paths" "asynchronous" "${stageNumber}" "${stageTotal}";bb_loop_servers "bb_STAGE_testWritePaths_task" "write path permissions test completed" "true";bb_time_stageTimer;};bb_STAGE_testWritePaths_task(){ bb_display_msgColor "TASK==>_mc" "TASK: display paths to be write tested" "" "1" "1" "1";bb_display_msgColor "ALERT-->_mc" "these paths will be resolved per server" "" "2" "0" "1";bb_display_msgColor "INFO-B-->_mc" "\${connect_targetFolder}" "" "1" "0" "1";bb_display_msgColor "INFO-B-->_mc" "\${connect_installFolder}" "" "1" "0" "1";sectionList="connect";for section in "${!arrayWritetest[@]}";do jsonSection="${arrayWritetest[$section]}";if [[ "${sectionList}" != *"${jsonSection}"* ]];then bb_json_recursiveArrays "${loopServerId}_${jsonSection}" "${bbv_jsonServersPath}";sectionList="${sectionList} ${jsonSection}";fi;done;for section in "${!arrayWritetestNested[@]}";do jsonSection="${arrayWritetestNested[$section]}";if [[ "${sectionList}" != *"${jsonSection}"* ]];then bb_json_recursiveArrays "${loopServerId}_${jsonSection}" "${bbv_jsonServersPath}";sectionList="${sectionList} ${jsonSection}";fi;done;bb_array_declareJsonCurrentLoopServer;bb_array_declareJsonPaths;if [[ "${loopServerId}" == "1" ]];then bb_display_msgColor "ALERT-->_mc" "example: server1 - displaying write test paths" "" "0" "0" "1";for key in "${!arrayWritetest[@]}";do path=${arrayJsonCurrentLoopServer[$key]};pathPartiallyResolved=$(bb_path_getUnresolvedPath "${path}");bb_display_equalSpacing "${key}:" "${pathPartiallyResolved}" "${cyan}" "${white}" "0" "true";done;declare -a arrayNested;count=0;if [[ "${#arrayWritetestNested[@]}" -ne "0" ]];then bb_display_msgColor "ALERT-->_mc" "example: server1 - displaying paths defined within nested objects or arrays" "" "0" "0" "1";for pk in "${!arrayJsonPathsPartiallyResolved[@]}";do path=${arrayJsonPathsPartiallyResolved[$pk]};if [[ "${path}" == *","* ]];then bb_array_stringDelimeter "," "${path}";for p in "${arrayTmp[@]}";do arrayNested[$count]="$(bb_json_replaceVariables ${p})";bb_display_equalSpacing "${pk}:" "${p}" "${cyan}" "${white}" "0" "true";((count++));done;else arrayNested[$count]="$(bb_json_replaceVariables ${path})";bb_display_equalSpacing "${pk}:" "${path}" "${cyan}" "${white}" "0" "true";((count++));fi;done;fi;fi;bb_display_msgColor "TASK==>_mc" "TASK: test write paths on each server" "" "1" "1" "1";bb_display_msgColor "INFO-B-->_mc" "on server:" "${onServer}" "2" "0" "0";for key in "${!arrayWritetest[@]}";do path=${arrayJsonCurrentLoopServer[$key]};bb_ssh_testWritePaths "${connect_sshUser}" "${connect_pubIp}" "${connect_sshKeyLocal}" "50" ${path}& pid=${!};details="${onServer} with pid ${cyan}$pid${reset} --> ${path}${reset}";arrayPidDetails["${pid}"]="${details}";arrayPids+=" $pid";sleep 0.1;done;if [[ "${#arrayWritetestNested[@]}" -ne "0" ]];then for np in "${arrayNested[@]}";do bb_ssh_testWritePaths "${connect_sshUser}" "${connect_pubIp}" "${connect_sshKeyLocal}" "50" "${np}"& pid=${!};details="${onServer} with pid ${cyan}$pid${reset} --> ${np}${reset}";arrayPidDetails["${pid}"]="${details}";arrayPids+=" $pid";sleep 0.1;done;fi;};bb_VERSION="0.5.1";script_name=$(basename -- "$0");script_author="jon dowson";script_start=$(date +%s);script_start_display=$(date);bb(){ thisFunc=${FUNCNAME[0]};if [[ "${1}" == "deployBlock" ]]||[[ "${1}" == "adhoc" ]];then bbv_remoteMode="${1}";bbv_jsonServers="${2}";connect_targetFolder="${3}";build_block="${4}";loopServerId="${5}";bbv_adhoc="${6}";bbv_bbPath="${connect_targetFolder}bash-blocks/";bbv_jsonServersPath="${bbv_bbPath}blocks/${build_block}/servers_json/${bbv_jsonServers}";if [ -f "${bbv_bbPath}framework/bb" ];then chmod 700 "${bbv_bbPath}framework/bb";file="${bbv_bbPath}framework/L0/bb_os_getLocal.bash";source ${file};file="${bbv_bbPath}framework/L0/bb_source_bb.bash";source ${file};bb_source_bb;bb_source_block;else chmod 700 "${bbv_bbPath}bb";source "${bbv_bbPath}blocks/${build_block}/${build_block}";fi;chmod -R 700 "${bbv_bbPath}blocks/${build_block}/software/";bb_display_textFormatting;bb_array_bbSettingsSet "bbv_os" "$(bb_os_getLocal)";if [[ "${bbv_os}" != "Mac" ]];then bb_array_bbSettingsSet "bbv_jqFolderPath" "${bbv_bbPath}";bb_array_bbSettingsSet "bbv_jqFilePath" "${bbv_jqFolderPath}jq";jqCmd="${bbv_jqFilePath}";bb_filesFolders_fileFolderExists "jq file not found" "${thisFunc}: line - ${LINENO}" "1" "true" "${bbv_jqFolderPath}" "file" "jq";chmod 700 "${bbv_bbPath}jq";else bb_array_bbSettingsSet "bbv_jqFolderPath" "/usr/local/Cellar/jq/1.6/bin/";bb_array_bbSettingsSet "bbv_jqFilePath" "${bbv_jqFolderPath}jq";jqCmd="${bbv_jqFilePath}";bb_filesFolders_fileFolderExists "jq file not found" "${thisFunc}: line - ${LINENO}" "1" "true" "${bbv_jqFolderPath}" "file" "jq";chmod 700 "${bbv_bbPath}jq";fi;bb_json_recursiveArrays "build" "${bbv_jsonServersPath}";bb_array_declareJsonAllServers;bbv_buildFolderPath="${bbv_bbPath}blocks/${build_block}/builds/${build_buildFolder}/";bbv_connectJsonPath="${bbv_bbPath}servers_json_connect/${build_connectJson}";bb_defaults_set;block_defaults_set;bb_array_declareBbDefaults;bb_array_declareBlockDefaults;source ${bbv_bbPath}tmp/payload/bb_array_settings;source ${bbv_bbPath}tmp/payload/block_array_settings;bb_file_deserialiseToArray "${bbv_bbPath}tmp/payload/arrayBlockSoftware" "false";if [[ "${bbv_default_debug}" == "true" ]];then bb_debug_remoteSetup;set -x;fi;if [[ ${bbv_os} == *"Ubuntu"* ]];then res=$(bb_bash_configDebian);source ${HOME}/.bashrc;else source ${HOME}/.bash_profile;fi;if [[ "${build_connectJson}" != "" ]];then errMsg="cannot find file specified by build.connectJson: ${build_connectJson}";callMsg="${thisFunc}: line - ${LINENO}";returnCode="1";abortOnFail="true";path="${bbv_bbPath}servers_json_connect/";fileOrFolder="file";fileToCheck="${build_connectJson}";bb_filesFolders_fileFolderExists "${errMsg}" "${callMsg}" "${returnCode}" "${abortOnFail}" "${path}" "${fileOrFolder}" "${fileToCheck}";else inlineTest=$(${jqCmd} -r '.servers.server'${loopServerId}'.connect.targetFolder' ${bbv_jsonServersPath});bb_error_comparisonTest "${thisFunc}: line - ${LINENO}" "missing connection block definition in ${red}${bbv_jsonServers}${reset}" "${inlineTest}" "==" "null" "true";fi;bb_json_recursiveArrays "build" "${bbv_jsonServersPath}";bb_array_declareJsonCurrentLoopServer;bb_array_bbSettingsSet "bbv_numberOfServers" "1";bb_loop_servers "STAGE_deployBlock" "false" "false";bb_tidy_removeTmpFolder;exit 0;fi;bbv_parentPath=$(cd "$(dirname "${BASH_SOURCE[0]}")";pwd -P);cd "${bbv_parentPath}";bbv_bbPath="$(pwd)/";mkdir -p "${bbv_bbPath}servers_json_connect";mkdir -p "${bbv_bbPath}blocks";mkdir -p "${bbv_bbPath}installed-blocks";if [ -f "${bbv_bbPath}framework/bb" ];then chmod 700 "${bbv_bbPath}framework/bb";file="${bbv_bbPath}framework/L0/bb_os_getLocal.bash";source ${file};file="${bbv_bbPath}framework/L0/bb_source_bb.bash";source ${file};bb_source_bb;else chmod 700 "${bbv_bbPath}bb";fi;chmod 700 "${bbv_bbPath}jq";bb_display_textFormatting;bb_tidy_removeTmpFolder;bb_array_bbSettingsSet "bbv_parentPath" "${bbv_parentPath}";bb_array_bbSettingsSet "bbv_bbPath" "${bbv_bbPath}";bb_array_bbSettingsSet "bbv_os" "$(bb_os_getLocal)";if [[ "${bbv_os}" == *"Ubuntu"* ]];then res=$(bb_bash_configDebian);source ${HOME}/.bashrc;else source ${HOME}/.bash_profile;fi;if [ -f "${bbv_bbPath}.git" ];then chmod 700 "${bbv_bbPath}.git";fi;if [ -f "${bbv_bbPath}jq" ];then chmod 700 "${bbv_bbPath}jq";fi;if [[ "${bbv_os}" != "Mac" ]];then bb_array_bbSettingsSet "bbv_jqFolderPath" "${bbv_bbPath}";bb_array_bbSettingsSet "bbv_jqFilePath" "${bbv_jqFolderPath}jq";jqCmd="${bbv_jqFilePath}";bb_filesFolders_fileFolderExists "jq file not found" "${thisFunc}: line - ${LINENO}" "1" "true" "${bbv_jqFolderPath}" "file" "jq";else bb_array_bbSettingsSet "bbv_jqFolderPath" "/usr/local/Cellar/jq/1.6/bin/";bb_array_bbSettingsSet "bbv_jqFilePath" "${bbv_jqFolderPath}jq";jqCmd="${bbv_jqFilePath}";bb_filesFolders_fileFolderExists "jq file not found" "${thisFunc}: line - ${LINENO}" "1" "true" "${bbv_jqFolderPath}" "file" "jq";fi;bb_array_bbSettingsSet "bbv_targetFolder_hostMachine" $(printf "${bbv_parentPath}"|sed 's,bash-blocks.*,,');if [[ "${1}" != "--block" ]]&&[[ "${1}" != "-b" ]]&&[[ "${1}" != "-h" ]]&&[[ "${1}" != "--help" ]]&&[[ "${1}" != "-ib" ]]&&[[ "${1}" != "--installblock" ]];then errMsg="specify the help, block or block install flag first";returnCode="1";callingMsg="${thisFunc}: line - ${LINENO}";bb_error_standard "${errMsg}" "${returnCode}" "${callingMsg}" "true";fi;while test $# -gt 0;do case "$1" in -ib|--installblock) bb_array_bbSettingsSet "bbv_blockToInstall" "$(shift&&echo $1)";if [[ "${bbv_blockToInstall}" == "bb" ]];then bb_install_bb;else shift;shift;bb_array_bbSettingsSet "bbv_switch_blockToInstall" "true";bb_install_block;fi;exit 0 ;; -h|--help) bb_array_bbSettingsSet "bbv_switch_help" "true";if [[ "${bbv_switch_block}" == "true" ]];then bb_display_bbBanner;bb_help_bb;block_help_block;bb_help_listBlockJson;else bb_display_bbBanner;bb_help_bb;bb_help_listBlockJson;fi;exit 0 ;; -b|--block) shift;bb_array_bbSettingsSet "build_block" "${1}";shift;if [ -f "${bbv_bbPath}framework/bb" ];then bb_source_block;else source "${bbv_bbPath}blocks/${build_block}/${build_block}";bb_source_block;fi;bb_defaults_set;block_defaults_set;bb_array_bbSettingsSet "bbv_switch_block" "true" ;; -s|--servers) bb_array_bbSettingsSet "bbv_jsonServers" "$(shift&&echo $1)";shift;shift;bb_array_bbSettingsSet "bbv_switch_json" "true" ;; -sbs|--sendblocksware) bb_array_blockSettingsSet "block_default_sendBlockSware" "$(shift&&echo $1)";shift;shift;bb_array_blockSettingsSet "block_switch_sendBlockSware" "true" ;; -mbf|--makebuildfolder) bb_array_blockSettingsSet "block_default_makeBuildFolder" "$(shift&&echo $1)";shift;shift;bb_array_blockSettingsSet "block_switch_makebuildfolder" "true" ;; -aof|--abortonfail) bb_array_bbSettingsSet "bbv_default_abortOnFail" "$(shift&&echo $1)";shift;shift;bb_array_bbSettingsSet "bbv_switch_abortOnFail" "true" ;; -d|--debug) bb_array_bbSettingsSet "bbv_default_debug" "$(shift&&echo $1)";shift;shift;bb_array_bbSettingsSet "bbv_switch_debug" "true" ;; -sp|--stagepause) bb_array_bbSettingsSet "bbv_default_stagePause" "$(shift&&echo $1)";shift;shift;bb_array_bbSettingsSet "bbv_switch_stagePause" "true" ;; *) thisFlag="${1}";flagValue=$(shift&&echo "${1}");block_flag_handle "${thisFlag}" "${flagValue}";shift;shift ;; esac;done;bb_array_declareBbDefaults;bb_array_declareBlockDefaults;bb_array_serialiseToFile bb_array_settings;bb_array_serialiseToFile block_array_settings;bb_flag_rules;block_flag_rules;bb_array_bbSettingsSet "bbv_existsRemoteServer" "false";bb_array_bbSettingsSet "bbv_buildFolderStageHasRun" "false";bb_array_bbSettingsSet "bbv_jsonServersPath" "${bbv_bbPath}blocks/${build_block}/servers_json/${bbv_jsonServers}";errMsg="json server file not found: ${bbv_jsonServers}";callMsg="${thisFunc}: line - ${LINENO}";returnCode="1";abortOnFail="true";path="${bbv_bbPath}blocks/${build_block}/servers_json/";fileOrFolder="file";fileToCheck="${bbv_jsonServers}";bb_filesFolders_fileFolderExists "${errMsg}" "${callMsg}" "${returnCode}" "${abortOnFail}" "${path}" "${fileOrFolder}" "${fileToCheck}";bb_error_isJqWellFormed "${jqCmd} type -e ${bbv_jsonServersPath}" "json is not well formed" "${thisFunc}: line - ${LINENO}" "true";bbv_numberOfServers=$(bb_string_trimWhiteSpace $(${jqCmd} -r '.servers|keys[]' ${bbv_jsonServersPath}|wc -l));bb_array_bbSettingsSet "bbv_numberOfServers" "${bbv_numberOfServers}";bb_error_comparisonTest "${thisFunc}: line - ${LINENO}" "zero number of servers" "${bbv_numberOfServers}" "-eq" "0" "true";bb_json_recursiveArrays "build" "${bbv_jsonServersPath}";bb_array_declareJsonAllServers;bbv_buildFolderPath="${bbv_bbPath}blocks/${build_block}/builds/${build_buildFolder}/";mkdir -p "${bbv_buildFolderPath}";bbv_connectJsonPath="${bbv_bbPath}servers_json_connect/${build_connectJson}";if [[ "${build_connectJson}" != "" ]];then bb_filesFolders_fileFolderExists "cannot find file specified by build.connectJson: ${build_connectJson}" "${thisFunc}: line - ${LINENO}" "1" "true" "${bbv_bbPath}servers_json_connect/" "file" "${build_connectJson}";bbv_numberOfConnectServers=$(${jqCmd} -r '.servers|keys[]' ${bbv_connectJsonPath}|wc -l);bb_error_comparisonTest "${thisFunc}: line - ${LINENO}" "different number of servers specified for connection settings" "${bbv_numberOfServers}" "-ne" "${bbv_numberOfConnectServers}" "true";bb_json_recursiveArrays "all" "${bbv_connectJsonPath}";else for loopServerId in $(seq 1 ${bbv_numberOfServers});do inlineTest=$(${jqCmd} -r '.servers.server'${loopServerId}'.connect.targetFolder' ${bbv_jsonServersPath});bb_error_comparisonTest "${thisFunc}: line - ${LINENO}" "missing connection block definition in ${red}${bbv_jsonServers}${reset}" "${inlineTest}" "==" "null" "true";done;fi;if [[ "${bbv_default_debug}" == "true" ]];then exec> >(tee -i ${bbv_bbPath}$(date +%F_%T)_bb_debug.log);bb_debug_bbLocalSetup;fi;"${build_block}";bb_tidy_removeTmpFolder;bb_time_blockRunDuration;bb_display_msgColor "INFO-B-->_mc" "block ${build_block} took: " "${cyan}${diff}[s]${reset}" "0" "1" "2";};bbInput="$@";if [[ $BASH_VERSINFO<4 ]];then if [[ $BASH_UPGRADE_ATTEMPTED != 1 ]];then export BASH_UPGRADE_ATTEMPTED=1;export PATH=/usr/local/bin:"$PATH":/bin;exec "$(which bash)" --noprofile "$0" """$@""";else export OLD_BASH=1;fi;else :;fi;trap "exit 1" TERM;export TOP_PID=$$;declare -A block_array_settings;declare -A bb_array_settings;declare -A arrayJsonCurrentLoopServer;declare -A arrayJsonAllServers;declare -A arrayTaskReportMessages;declare -A arrayJsonPathsPartiallyResolved;declare -A arrayJsonPathsResolved;declare -A arrayPidDetails;declare -A arrayParentsChildren;declare -A arrayWritetest;declare -A arrayWritetestNested;declare -A arrayTaskActions;declare -A arrayPidFailAllStages;declare -a arrayJqListToArray;declare -a arrayLocalFunctions;declare -a arrayBlockStages;declare -a arrayStripExtensions;declare -a arrayPids;declare -a arrayPidSuccess;declare -a arrayPidFail;declare -a arrayGenerationParents;declare -a arrayBlockSoftware;declare -a arrayTmp;bb ${bbInput};